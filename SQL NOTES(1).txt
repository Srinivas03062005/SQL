
Q) WHAT IS THE ROLE OF SQL IN TODAYS WORLD?
ANS) SQL IS VERY IMPORTANT EVEN MORE IMPORTANT THAN PROGRAMMING LANGUAGES THESE DAYS
FOR A IT ENGINEER WHY? BECAUSE IF WE TALK ABOUT DATA ENGINEER , DATA SCIENCE ,WEB DEVELOPMENT
FULL STACK DEVELOPMENT IT IS REQUIRED FOR EACH AND EVERY ONE 

THE DATABASE WE ARE USING IS  : MYSQL




SESSION 1
_________

Q)WHAT IS A DATABASE?
ANS) A DATABASE IS A COLLECTION OF DATA AND HOLDS THIS DATA IN THE FORM OF TABLES


Q) WHAT IS A TABLE?
ANS) A TABLE IS NOTHING BUT A WAY OF STORING THE DATA IN THE FORM OF ROWS AND COLUMNS

-> TABLE IS SIMILAR TO EXCEL SPREADSHEET

___________________________________________________________________________________________________________________________________________________________________________________________


Q) WHEN A EXCEL SPREADSHEET CAN HOLD THE DATA SAME WAY THEN WHY DO WE NEED THESE DATABASES AND TABLES
ANS) 

IMAGINE YOU HAVE A TOY BOX AND YOU WANT TO KEEP TRACK OF ALL YOUR TOYS AND WHO YOU LEND THEM TO.

SPREADSHEET: IT'S LIKE WRITING ALL THE TOY NAMES, YOUR FRIENDS' NAMES, AND WHEN THEY BORROWED TOYS ON 
A BIG PIECE OF PAPER. IT WORKS FOR A FEW TOYS, BUT IF YOU HAVE HUNDREDS OF TOYS, IT BECOMES MESSY, 
HARD TO FIND THINGS, AND YOU MIGHT MAKE MISTAKES.

DATABASE: IT'S LIKE HAVING A SUPER-SMART TOY ORGANIZER. IT HAS SEPARATE DRAWERS FOR TOYS, FRIENDS, 
AND BORROWING DATES. IF YOU WANT TO KNOW WHO BORROWED YOUR RED CAR, YOU JUST ASK, AND IT TELLS YOU 
RIGHT AWAY!

DATABASES ARE LIKE MAGIC TOY ORGANIZERS THAT HELP WHEN THINGS GET BIG AND COMPLICATED!
___________________________________________________________________________________________________________________________________________________________________________________________




-> THE DATABASE PROVIDES US THE CAPABILITY TO ACCESS AND MANIPULATE THIS DATA.


___________________________________________________________________________________________________________________________________________________________________________________________


--> KIND OF DATA BASES THAT WE HAVE 
MOSTLY THESE DATA BASES CAN BE GROUPED INTO 2 CATEGORIES 

1)RELATIONAL DATABASE - THAT ORGANIZES DATA INTO TABLES(ROWS AND COLUMNS) 
THE TABLES HAVE RELATION BETWEEN THEM.
EXAMPLES FOR RELATIONAL -> MYSQL,SQL SERVER,POSTRESQL,SQLITE,MARIADB



2)NOSQL DATABASE OR NON-RELATIONAL DATABASE - HERE THE DATA IS NOT STORE 
IN THE FORM ROWS AND COLUMNS
EXAMPLES FOR NON-RELATIONAL -> HBASE,MONGODB,CASSANDRA


NON-RELATIONAL DATABASES STORE DATA IN DIFFERENT FORMATS DEPENDING ON THE TYPE.

HERE ARE SOME COMMON FORMATS USED IN NON-RELATIONAL DATABASES:

1)DOCUMENT STORES
DATA IS STORED AS DOCUMENTS (USUALLY JSON,XML), WHICH CAN CONTAIN COMPLEX, NESTED STRUCTURES.
EXAMPLE: A DOCUMENT REPRESENTING A PRODUCT MIGHT LOOK LIKE THIS:

{
  "ProductID": "123",
  "Name": "Laptop",
  "Specifications": 
  {
    "Processor": "Intel i7",
    "RAM": "16GB"
  },
  "Price": 1200
}

2) KEY-VALUE STORES
DATA IS STORED AS KEY-VALUE PAIRS. EACH PIECE OF DATA IS ACCESSED USING A UNIQUE KEY, AND THE VALUE CAN BE A SIMPLE DATA TYPE OR A COMPLEX OBJECT.

EXAMPLE:
Key: "product_123"
Value: {"Name": "Laptop", "Price": 1200}

3) GRAPH DATABASES
DATA IS STORED AS NODES (ENTITIES) AND EDGES (RELATIONSHIPS BETWEEN ENTITIES).

EXAMPLE: A NODE MIGHT REPRESENT A "PERSON" WITH PROPERTIES LIKE "NAME" AND "AGE," AND AN EDGE MIGHT REPRESENT A "FRIEND" RELATIONSHIP BETWEEN TWO NODES.

___________________________________________________________________________________________________________________________________________________________________________________________



-> SQL(STRUCTURED QUERY LANGUAGE)
            |
            |
            V
   BECAUSE THIS LANGUAGE IS USED TO DEAL WITH STRUCTURED DATA WHICH IS IN THE FORM OF ROWS AND COLUMNS


SQL IS A PROGRAMMING LANGUAGE USED TO MANAGE AND MANIPULATE DATA IN RELATIONAL DATABASES. IT ALLOWS YOU TO PERFORM OPERATIONS LIKE QUERYING, INSERTING, UPDATING, AND DELETING DATA.

MYSQL IS AN OPEN-SOURCE DATABASE MANAGEMENT SYSTEM THAT USES SQL TO STORE AND MANAGE DATA.


-> A QUERY IN SQL IS A REQUEST TO PERFORM AN OPERATION (LIKE RETRIEVING OR MODIFYING DATA) IN A DATABASE.

___________________________________________________________________________________________________________________________________________________________________________________________



=> INSTALLATION
 
GOORMIDE
CREATE A CONTAINER
mysql-ctl cli;
show databases; -> IS TO GET A LIST OF DATABASES WHICH ARE ALREADY PRESENT
create database databasename; -> IT IS USED TO CREATE OUR OWN DATABASE
drop database databasename; -> IT IS USED TO DELETE A DATABASE
USE databasename -> IS USED TO SELECT A SPECIFIC DATABASE TO WORK WITH. AFTER 
                    EXECUTING THIS COMMAND, ALL SUBSEQUENT SQL STATEMENTS WILL 
                    BE EXECUTED WITHIN THE CONTEXT OF THE SPECIFIED DATABASE 
                    UNTIL ANOTHER DATABASE IS SELECTED OR THE SESSION ENDS.
SELECT database(); -> IS USED TO DETERMINE THE NAME OF THE CURRENTLY SELECTED 
                      DATABASE IN THE CURRENT SESSION. IF NO DATABASE HAS BEEN 
                      SELECTED, IT WILL RETURN NULL.
CREATE TABLE tablename -> USED TO CREATE A TABLE IN  DATABASE
( 
   name  varchar(50),
   age   INT,
   salary INT
);


int for numeric
varchar for string upto 255 characters


show tables; -> IS USED TO SEE LIST OF ALL THE TABLES PRESENT IN THE CURRENTLY SELECTED DATABASE.
describe tablename; -> IS USED TO RETRIEVE THE STRUCTURE  OF A SPECIFIED TABLE.
drop table tablename; -> IS USED TO DELETE AN EXISTING TABLE FROM THE DATABASE.

___________________________________________________________________________________________________________________________________________________________________________________________




SESSION 2
_________


CRUD Operations 

CREATE  ->  INSERT STATEMENTS   ADDS NEW RECORDS TO A TABLE.
READ    ->  SELECT STATEMENTS   RETRIEVES DATA FROM A TABLE.
UPDATE  ->  UPDATE STATEMENTS   MODIFIES EXISTING RECORDS IN A TABLE.
DELETE  ->  DELETE STATEMENTS   REMOVES RECORDS FROM A TABLE.
 

-> CREATION OF TABLE AND INSERT STATEMENTS
EMPLOYEE TABLE
WE PREFER TO HIRE FROM BANGALORE



CREATE TABLE employee
(
      firstname varchar(20),
      middlename varchar(20),
      lastname varchar(20),
      age int,
      salary int,
      location varchar(20)
);

HOW TO SEE DATA INSIDE A TABLE -> select * from tablename;
TO INSERT VALUES INTO TABLES -> INSERT INTO tablename VALUES();

INSERT INTO employee(firstname,middlename,lastname,age,salary,location) VALUES ('kapil','kumar','sharma',28,10000,'bangalore');
-> THIS IS GOOD PRACTICE

INSERT INTO employee VALUES ('satish','kumar','sharma',28,10000,'bangalore');
-> THIS IS NOT RECOMMEND

INSERT INTO employee(firstname,lastname,age,salary,location) VALUES ('rajesh','sharma',28,20000,'bangalore');
-> HERE WE HAVE NOT GIVEN THE VALUE MIDDLENAME SO IN THE PLACE OF MIDDLENAME WE WILL GET NULL 

INSERT INTO employee VALUES ('rajesh','sharma',28,20000,'bangalore');
-> IF WE GIVE LIKE THIS WE WILL GET ERROR

INSERT INTO employee(firstname,middlename,lastname,age,salary,location) VALUES ('kapil','kumar','sharma',28,10000,'bangalore'),('satish','kumar','sinha',30,20000,'bangalore');


'  '  '  -> "  '  "
         -> '  \' '




NULL
____


CREATE TABLE employee
(
      firstname varchar(20) NOT NULL,
      middlename varchar(20),
      lastname varchar(20) NOT NULL,
      age int NOT NULL,
      salary int NOT NULL,
      location varchar(20) NOT NULL
);

THE MIDDLENAME CAN ACCEPT NULL VALUES, MEANING IT'S OPTIONAL TO PROVIDE A VALUE.
OTHER COLUMNS LIKE FIRSTNAME, LASTNAME, AGE, SALARY, AND LOCATION CANNOT BE NULL DUE TO THE NOT NULL CONSTRAINT.





DEFAULT VALUES
______________


CREATE TABLE employee
(
      firstname varchar(20) NOT NULL,
      middlename varchar(20),
      lastname varchar(20) NOT NULL,
      age int NOT NULL,
      salary int NOT NULL,
      location varchar(20) DEFAULT 'bangalore'
);

IS USED TO SPECIFY A VALUE THAT WILL BE AUTOMATICALLY INSERTED INTO A COLUMN IF NO VALUE IS PROVIDED DURING AN 
INSERT OPERATION. IN YOUR TABLE, THE LOCATION COLUMN WILL AUTOMATICALLY HAVE THE VALUE 'BANGALORE' IF NO VALUE 
IS SPECIFIED WHEN INSERTING A RECORD.


___________________________________________________________________________________________________________________________________________________________________________________________


SESSION 3  -> PRIMARY KEY VS UNIQUE KEY
________________________________________




PRIMARY KEY
___________

CREATE TABLE employee
(
      id int PRIMARY KEY,
      firstname varchar(20) NOT NULL,
      middlename varchar(20),
      lastname varchar(20) NOT NULL,
      age int NOT NULL,
      salary int NOT NULL,
      location varchar(20) NOT NULL DEFAULT 'bangalore'
);


INSERT INTO employee(id,firstname,lastname,age,salary) VALUES (1,'rajesh','sharma',28,10000);

-> A PRIMARY KEY ENSURES THAT THE VALUES IN THE ID COLUMN ARE UNIQUE FOR EACH ROW. NO TWO ROWS IN THE EMPLOYEE TABLE CAN HAVE THE SAME ID VALUE.
-> A PRIMARY KEY COLUMN CANNOT HAVE NULL VALUES. THIS ENSURES THAT EVERY EMPLOYEE WILL HAVE A UNIQUE IDENTIFIER (THE ID) WHICH CANNOT BE LEFT EMPTY.




AUTO INCREMENT
______________

CREATE TABLE employee
(
      id int AUTO_INCREMENT,
      firstname varchar(20) NOT NULL,
      middlename varchar(20),
      lastname varchar(20) NOT NULL,
      age int NOT NULL,
      salary int NOT NULL,
      location varchar(20) NOT NULL DEFAULT 'bangalore',
      PRIMARY KEY(id)
);

-> A TABLE CAN ONLY HAVE ONE AUTO-INCREMENTING COLUMN
-> THE AUTO COLUMN MUST BE DEFINED AS A KEY, BUT IT DOESNOT HAVE TO BE THE PRIMARY KEY OR UNIQUE KEY.
-> "IS USED WITH A COLUMN TO AUTOMATICALLY GENERATE A UNIQUE VALUE WHENEVER A NEW ROW IS INSERTED INTO A 
    TABLE. THIS IS COMMONLY APPLIED TO PRIMARY KEY COLUMNS TO ENSURE THAT EACH RECORD HAS A UNIQUE IDENTIFIER."




UNIQUE KEY
__________

UNIQUE KEY CAN HOLD NULL 

FOR EXAMPLE IN MYSQL A UNIQUE KEY CAN HOLD ANY NUMBER OF NULL VALUES

IN SOME OF THE OTHER FAMOUS DATABASES UNIQUE KEY CAN HOLD ONLY ONE NULL

SO THE PURPOSE OF UNIQUE KEY IS TO MAKE SURE THE VALUES DO NOT DUPLICATE 

WE CAN HAVE ONLY ONE PRIMARY KEY BUT MULTIPLE UNIQUE KEYS  IN A TABLE 



EXTRA PRIMARY KEY CONCEPT
_________________________

CREATE TABLE employee
(
    firstname varchar(20) PRIMARY KEY, 
    lastname varchar(20) PRIMARY KEY,  
    age int NOT NULL,
);

THIS IS INCORRECT BECAUSE YOU'RE ATTEMPTING TO ASSIGN TWO SEPARATE PRIMARY KEYS TO FIRSTNAME AND LASTNAME. 
YOU SHOULD EITHER:
DEFINE A SINGLE PRIMARY KEY ON ONE COLUMN, OR
DEFINE A COMPOSITE PRIMARY KEY ACROSS BOTH FIRSTNAME AND LASTNAME TOGETHER.


CREATE TABLE employee
(
      firstname varchar(20) NOT NULL,
      lastname varchar(20) NOT NULL,
      age int NOT NULL,
      PRIMARY KEY(firstname,lastname)
);

INSERT INTO employee VALUES('kapil','sharma',28); 

INSERT INTO emplyoee VALUES('kapil','sinha',28);
THIS IS ALLOWED

INSERT INTO emplyoee VALUES('kapil','sharma',28);
THIS IS NOT ALLOWED



EXTRA UNIQUE KEY CONCEPT
_________________________

CREATE TABLE employee
(
    firstname varchar(20) UNIQUE,  
    lastname varchar(20) UNIQUE,   
    age int 
);

THIS IS CORRECT 
___________________________________________________________________________________________________________________________________________________________________________________________



SESSION 4  -> UPDATE ,DELETE, ALTER, DDL vs DML
_______________________________________________


CRUD Operations 

CREATE  ->  INSERT STATEMENTS   ADDS NEW RECORDS TO A TABLE.
READ    ->  SELECT STATEMENTS   RETRIEVES DATA FROM A TABLE.
UPDATE  ->  UPDATE STATEMENTS   MODIFIES EXISTING RECORDS IN A TABLE.
DELETE  ->  DELETE STATEMENTS   REMOVES RECORDS FROM A TABLE.



CREATE TABLE employee
(
      id int PRIMARY KEY,
      firstname varchar(20) NOT NULL,
      middlename varchar(20),
      lastname varchar(20) NOT NULL,
      age int NOT NULL,
      salary int NOT NULL,
      location varchar(20) NOT NULL DEFAULT 'bangalore'
);


INSERT INTO employee(id,firstname,lastname,age,salary) VALUES (1,'rajesh','sharma',28,10000);


INSERT INTO employee(id,firstname,lastname,age,salary) VALUES (2,'kapil','sharma',30,20000);


INSERT INTO employee(id,firstname,lastname,age,salary) VALUES (3,'Maneesh','sharma',32,30000);


SELECT
______

SELECTING ALL COLUMNS(IT SELECTS EVERY COLUMN)
select * from employee;

SELECTING SPECIFYING COLUMNS
select firstname,lastname from employee;


select * from employee where age > 29;
IT WILL ONLY GIVE FEW ROWS WHICH WILL HAVE AGE > 29

select * from employee where firstname='Maneesh';
IT WILL ONLY GIVE FEW ROWS WHICH WILL HAVE FIRSTNAME AS MANEESH

select * from employee where firstname='maneesh';
IN THE TABLE WE ARE HAVING M BUT I AM TAKING SMALL STILL IT WORKS 
BY DEFAULT IT IS CASE INSENSITIVE

IF WE WANT TO MAKE IT CASE SENSITIVE USE AS BELOW
select * from employee where binary firstname='maneesh';
IT WILL NOT WORK 
select * from employee where binary firstname='Maneesh';
IT WILL WORK 

-> ALIAS 
select firstname as name,lastname as surname from employee;
AFTER PRINTING TABLE , NAME TAKES FIRSTNAME PLACE AND SURNAME TAKES LASTNAME PLACE


UPDATE
______

update employee set lastname = 'sinha' where firstname = 'Maneesh';

update employee set location = 'Hyderabad' where firstname = 'kapil';

update employee set location = 'Hyderabad';
-> IT WILL DO THE UPDATE TO THE ENTIRE TABLE

update employee set salary = salary+5000;

update employee set location = 'bangalore' where firstname = 'Maneesh' and lastname = 'Sinha';


DELETE
______

delete from employee where id=3;

delete from employee;
IN THIS CASE EVERYTHING WILL BE DELETED



ALTER COMMAND
_____________

ALTER IS TO ALTER THE STRUCTURE OF THE TABLE 

alter table employee add column jobtitle varchar(50);

alter table employee drop column jobtitle;

alter table employee modify column firstname varchar(30);

alter table employee drop primary key;

alter table employee add primary key(id);



DDL VS DML
__________


DATA DEFINITION LANGUAGE -> DEALS WITH TABLE STRUCTURE
CREATE,ALTER,DROP -> DDL COMMANDS

DATA MANIPULATION LANGUAGE -> HERE WE DEAL WITH THE DATA DIRECTLY.
INSERT,UPDATE,DELETE -> DML COMMANDS 



delete from employee; -> REMOVES ALL RECORDS , DML COMMAND
IT DELETES THE RECORDS ONE BY ONE 


truncate table employee; -> ALSO REMOVES ALL RECORDS BUT THIS IS DDL COMMAND
TRUNCATE INTERNALLY DROPS THE TABLE.

___________________________________________________________________________________________________________________________________________________________________________________________



SESSION 5  -> FOREIGN KEY
_________________________

FOREIGN KEY CONSTRAINT:


Student Table:
______________


CREATE TABLE students
(
student_id int AUTO_INCREMENT,
student_fname varchar(30) NOT NULL,
student_lname varchar(30) NOT NULL,
student_mname varchar(30),
student_email varchar(30) NOT NULL,
student_phone varchar(15) NOT NULL,
student_alternate_phone varchar(15),
enrollment_date TIMESTAMP DEFAULT NOW() NOT NULL,
years_of_exp int NOT NULL,
student_company varchar(30),
batch_date varchar(30) NOT NULL,
source_of_joining varchar(30) NOT NULL,
location varchar(30) NOT NULL,
primary key(student_id),
unique key(student_email)
);



-> SEED DATA REFERS TO THE INITIAL SET OF DATA THAT IS INSERTED INTO A DATABASE TO 
   PROVIDE A BASELINE FOR DEVELOPMENT, TESTING, OR DEMONSTRATION PURPOSES.



Seed Data
_________

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('rohit','sharma','rohit@gmail.com','9191919191',6,'walmart','05-02-2021','linkedin','bangalore');

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('virat','kohli','virat@gmail.com','9292929292',3,'flipkart','05-02-2021','linkedin','hyderabad');

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('shikar','dhawan','shikar@gmail.com','9393939393',12,'amazon','19-02-2021','google','bangalore');

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('rahul','dravid','rahul@gmail.com','9494949494',8,'walmart','19-02-2021','quora','chennai');

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('kapil','dev','kapil@gmail.com','9294919191',15,'microsoft','05-02-2021','friend','pune'),
('brain','lara','brain@gmail.com','9394919191',18,'tcs','05-02-2021','youtube','pune'),
('carl','hooper','carl@gmail.com','9293519191',20,'wipro','19-02-2021','youtube','pune'),
('saurabh','ganguly','saurabh@gmail.com','9291975191',14,'wipro','19-02-2021','google','chennai');




SELECT Statement;
_________________

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students;


Courses Table:
______________

create table courses
(
course_id INT NOT NULL,
course_name varchar(30) NOT NULL,
course_duration_in_months INT NOT NULL,
course_fee INT NOT NULL,
PRIMARY KEY(course_id)
);


Seed Data
_________

insert into courses values (1,'big data',6,50000);
insert into courses values (2,'web development',3,20000);
insert into courses values (3,'data science',6,40000);
insert into courses values (4,'devops',1,10000);


drop table students;


Student Table:
______________


create table students
(
student_id INT AUTO_INCREMENT,
student_fname varchar(30) NOT NULL,
student_lname varchar(30) NOT NULL,
student_mname varchar(30),
student_email varchar(30) NOT NULL,
student_phone varchar(15) NOT NULL,
student_alternate_phone varchar(15),
enrollment_date TIMESTAMP DEFAULT NOW() NOT NULL,
selected_course INT NOT NULL DEFAULT 1,
years_of_exp INT NOT NULL,
student_company varchar(30),
batch_date varchar(30) NOT NULL,
source_of_joining varchar(30) NOT NULL,
location varchar(30) NOT NULL,
PRIMARY KEY(student_id),
UNIQUE KEY(student_email)
);

insert into students(student_fname,student_lname,student_email,student_phone,selected_course,years_of_exp,student_company,batch_date,source_of_joining,location) values('rohit','sharma','rohit@gmail.com','9191919191',2,6,'walmart','05-02-2021','linkedin','bangalore');

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('virat','kohli','virat@gmail.com','9292929292',3,'flipkart','05-02-2021','linkedin','hyderabad');

insert into students(student_fname,student_lname,student_email,student_phone,selected_course,years_of_exp,student_company,batch_date,source_of_joining,location) values('shikar','dhawan','shikar@gmail.com','9393939393',3,12,'amazon','19-02-2021','google','bangalore');

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('rahul','dravid','rahul@gmail.com','9494949494',8,'walmart','19-02-2021','quora','chennai');

insert into students(student_fname,student_lname,student_email,student_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('kapil','dev','kapil@gmail.com','9294919191',15,'microsoft','05-02-2021','friend','pune'),
('brain','lara','brain@gmail.com','9394919191',18,'tcs','05-02-2021','youtube','pune'),
('carl','hooper','carl@gmail.com','9293519191',20,'wipro','19-02-2021','youtube','pune'),
('saurabh','ganguly','saurabh@gmail.com','9291975191',14,'wipro','19-02-2021','google','chennai');

insert into students(student_fname,student_lname,student_email,student_phone,selected_course,years_of_exp,student_company,batch_date,source_of_joining,location) values('jaspreet','bumrah','jaspreet@gmail.com','9595959595',5,13,'walmart','19-02-2021','quora','chennai');
-> THERE IS NO COURSE WITH ID 5 , IF WE INSERT THIS IT GETS INSERTED , HERE COMES THE CONCEPT OF FOREIGN KEY 


SELECT Statement;
__________________

select student_id,enrollment_date,selected_course,student_fname,years_of_exp,student_company,batch_date,source_of_joining,location from students;


drop table students;


Creating students Table with Foreign Key constraint:
____________________________________________________


create table students
(
student_id INT AUTO_INCREMENT,
student_fname varchar(30) NOT NULL,
student_lname varchar(30) NOT NULL,
student_mname varchar(30),
student_email varchar(30) NOT NULL,
sudent_phone varchar(15) NOT NULL,
student_alternate_phone varchar(15),
enrollment_date TIMESTAMP NOT NULL,
selected_course INT NOT NULL DEFAULT 1,
years_of_exp INT NOT NULL,
student_company varchar(30),
batch_date varchar(30) NOT NULL,
source_of_joining varchar(30) NOT NULL,
location varchar(30) NOT NULL,
PRIMARY KEY(student_id),
UNIQUE KEY(student_email),
FOREIGN KEY(selected_course) REFERENCES courses(course_id)
);


parent - courses
child - students


insert into students(student_fname,student_lname,student_email,student_phone,selected_course,years_of_exp,student_company,batch_date,source_of_joining,location) values('jaspreet','bumrah','jaspreet@gmail.com','9595959595',5,13,'walmart','19-02-2021','quora','chennai');
-> THERE IS NO COURSE WITH ID 5 , NOW WE CANNOT INSERT IT 


delete from courses where course_id=2;
-> THIS WILL GIVE AN ERROR BECAUSE THERE IS A FOREIGN KEY CONSTRAINT

delete from courses where course_id=4;
-> THIS WILL NOT GIVE ANY ERROR BECAUSE THERE IS A FOREIGN KEY CONSTRAINT BUT WE ARE NOT OPTING THE COURSE THAT HAVE THE ID 4.









FOREIGN KEY IS THE FIELD IN ONE TABLE THAT REFERS TO PRIMARY KEY IN ANOTHER TABLE.

SELECTED_COURSE IS FOREIGN KEY IN STUDENTS TABLE WHICH REFERS TO COURSE_ID (PRIMARY KEY) IN COURSES TABLE.

THE TABLE WITH FOREIGN KEY IS CALLED CHILD TABLE, AND THE TABLE WITH PRIMARY KEY IS CALLED REFERENCE TABLE OR PARENT TABLE.

CONSTRAINTS ARE USED TO LIMIT THE TYPE OF DATA THAT CAN GO INTO A TABLE.

___________________________________________________________________________________________________________________________________________________________________________________________


SESSION 6  -> DISTINCT,ORDER BY,LIMIT,LIKE 
__________________________________________



DISTINCT:
_________

select DISTINCT location from students;
+-----------+
| location  |
+-----------+
| bangalore |
| chennai   |
| pune      |
+-----------+



ORDER BY:
_________

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students ORDER BY years_of_exp;
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com   |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai   |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com   |           15 | microsoft       | 05-02-2021 | friend            | pune      |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com   |           18 | tcs             | 05-02-2021 | youtube           | pune      |
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com    |           20 | wipro           | 19-02-2021 | youtube           | pune      |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students ORDER BY years_of_exp desc;
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com    |           20 | wipro           | 19-02-2021 | youtube           | pune      |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com   |           18 | tcs             | 05-02-2021 | youtube           | pune      |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com   |           15 | microsoft       | 05-02-2021 | friend            | pune      |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai   |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com   |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+


select student_fname from students ORDER BY years_of_exp;
+---------------+
| student_fname |
+---------------+
| rohit         |
| rahul         |
| saurabh       |
| kapil         |
| brain         |
| carl          |
+---------------+

select student_fname,years_of_exp  from students ORDER BY years_of_exp;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| rohit         |            6 |
| rahul         |            8 |
| saurabh       |           14 |
| kapil         |           15 |
| brain         |           18 |
| carl          |           20 |
+---------------+--------------+

select student_fname,years_of_exp  from students ORDER BY years_of_exp desc;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| carl          |           20 |
| brain         |           18 |
| kapil         |           15 |
| saurabh       |           14 |
| rahul         |            8 |
| rohit         |            6 |
+---------------+--------------+


select student_fname,years_of_exp  from students ORDER BY 2 ;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| rohit         |            6 |
| rahul         |            8 |
| saurabh       |           14 |
| kapil         |           15 |
| brain         |           18 |
| carl          |           20 |
+---------------+--------------+
SORTS THE RESULTS BY THE SECOND COLUMN SPECIFIED IN THE SELECT CLAUSE



select student_fname,years_of_exp  from students ORDER BY 1;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| brain         |           18 |
| carl          |           20 |
| kapil         |           15 |
| rahul         |            8 |
| rohit         |            6 |
| saurabh       |           14 |
+---------------+--------------+
SORTS THE RESULTS BY THE FIRST COLUMN SPECIFIED IN THE SELECT CLAUSE



select student_fname,years_of_exp  from students ORDER BY 1 desc;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| saurabh       |           14 |
| rohit         |            6 |
| rahul         |            8 |
| kapil         |           15 |
| carl          |           20 |
| brain         |           18 |
+---------------+--------------+


select student_fname,years_of_exp  from students ORDER BY years_of_exp,student_fname;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| rohit         |            6 |
| rahul         |            8 |
| saurabh       |           14 |
| kapil         |           15 |
| brain         |           18 |
| carl          |           20 |
+---------------+--------------+
PRIMARY: By years_of_exp in ascending order.
SECONDARY: Alphabetically by student_fname for ties in years_of_exp.



LIMIT:
______

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students ORDER BY years_of_exp LIMIT 3;
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com   |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai   |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students ORDER BY years_of_exp desc LIMIT 3;
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com  |           20 | wipro           | 19-02-2021 | youtube           | pune     |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com |           18 | tcs             | 05-02-2021 | youtube           | pune     |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com |           15 | microsoft       | 05-02-2021 | friend            | pune     |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+


-> WANT TO KNOW WHICH SOURCES LAST 5 CANDIDATES HAVE ENROLLED.
select source_of_joining from students ORDER BY enrollment_date desc LIMIT 5;
+-------------------+
| source_of_joining |
+-------------------+
| friend            |
| youtube           |
| youtube           |
| google            |
| linkedin          |
+-------------------+
-> FIRST, IT SORTS THE DATA ACCORDING TO THE ENROLLMENT_DATE IN DESCENDING ORDER.
   THEN, IT OUTPUTS THE TOP 5 RECORDS FROM THE SORTED RESULTS.




⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐

select DISTINCT source_of_joining from students ORDER BY enrollment_date desc LIMIT 5;
-> THIS WONT WORK
-> REASON WILL BE AVAILABLE IN THE NEXT SESSION 7

⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐





select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students O
RDER BY enrollment_date desc LIMIT 1;
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+


 select * from students ORDER BY enrollment_date desc LIMIT 0, 3;
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+-------------------+--------------+-----------------+------------+-------------------+------------+
| student_id | student_fname | student_lname | student_mname | student_email     | student_phone | student_alternate_phone | enrollment_date     | selected_course   | years_of_exp | student_company  | batch_date | source_of_joining | location |
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+-------------------+--------------+-----------------+------------+-------------------+------------+
| 6          | saurabh       | ganguly       | NULL          | saurabh@gmail.com | 9291975191    | NULL                    | 2022-07-09 00:03:09 | 3                 | 14           | wipro            | 19-02-2021 | google            | chennai  |
| 5          | carl          | hooper        | NULL          | carl@gmail.com    | 9293519191    | NULL                    | 2022-07-09 00:03:09 | 1                 | 20           | wipro            | 19-02-2021 | youtube           | pune     |
| 3          | kapil         | dev           | NULL          | kapil@gmail.com   | 9294919191    | NULL                    | 2022-07-09 00:03:09 | 4                 | 15           | microsoft        | 05-02-2021 | friend            | pune     |
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+-------------------+--------------+-----------------+------------+-------------------+------------+
-> 0: THIS IS THE OFFSET. IT MEANS "START FROM THE FIRST ROW" (0-INDEXED). THE RESULT WILL INCLUDE ROWS STARTING FROM THE VERY BEGINNING.
   3: THIS IS THE LIMIT. IT RESTRICTS THE OUTPUT TO ONLY 3 ROWS, STARTING FROM THE 0TH ROW (THE FIRST ROW).



LIKE:
_____


select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students where student_fname LIKE '%ra%';
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai  |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com   |           18 | tcs             | 05-02-2021 | youtube           | pune     |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
'%ra%'
THIS MATCHES ANY STRING THAT CONTAINS "ra" ANYWHERE IN THE TEXT.


 select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students where student_fname LIKE 'ra%';
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com |            8 | walmart         | 19-02-2021 | quora             | chennai  |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
'ra%'
THIS MATCHES ANY STRING THAT STARTS WITH "ra".


select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students where student_fname LIKE '%it';
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
'%it'
THIS MATCHES ANY STRING THAT ENDS WITH "it".



select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students where student_fname like '_____';
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com |           15 | microsoft       | 05-02-2021 | friend            | pune      |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com |           18 | tcs             | 05-02-2021 | youtube           | pune      |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
-> PATTERN MATCHES ANY student_fname WITH EXACTLY 5 CHARACTERS.



select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students where student_fname like '____';
+------------+---------------------+---------------+----------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email  | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+----------------+--------------+-----------------+------------+-------------------+----------+
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com |           20 | wipro           | 19-02-2021 | youtube           | pune     |
+------------+---------------------+---------------+----------------+--------------+-----------------+------------+-------------------+----------+

% AND _ ARE WILD CARD CHARACTERS.


'%at'

'%\%at'

'%\_at'
___________________________________________________________________________________________________________________________________________________________________________________________


SESSION 7 -> ORDER OF EXECUTION
_______________________________


-> IN SQL QUERIES, CLAUSES ARE EXECUTED BASED ON THE FOLLOWING ORDER :

FROM CLAUSE
JOIN CLAUSE
WHERE CLAUSE
GROUP BY CLAUSE
HAVING CLAUSE
SELECT CLAUSE
DISTINCT CLAUSE
ORDER BY CLAUSE
LIMIT CLAUSE



CASE 1:

select source_of_joining from students

ORDER OF EXECUTION:
___________________

1) FROM
-> THE SQL ENGINE IDENTIFIES THE SOURCE TABLE, WHICH IS students. IT PREPARES TO RETRIEVE DATA FROM THIS TABLE.

2) SELECT 
-> THE ENGINE SELECTS THE COLUMNS SPECIFIED IN THE SELECT CLAUSE, WHICH ARE source_of_joining. 
   THIS IS THE VALUE THAT WILL BE RETURNED IN THE RESULT SET.
 


CASE 2:

select source_of_joining, enrollment_date from students.

ORDER OF EXECUTION:
___________________

1) FROM
2) SELECT



CASE 3:

select source_of_joining, enrollment_date from students order by enrollment_date;

ORDER OF EXECUTION:
___________________

1) FROM 
2) SELECT 
3) ORDER BY 


CASE 4:

select source_of_joining from students order by enrollment_date;

ORDER OF EXECUTION:
___________________

1) FROM 
2) SELECT 
3) ORDER BY


⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐

CASE 5:

select distinct source_of_joining from students order by enrollment_date;
-> THIS WONT WORK

ORDER OF EXECUTION:
___________________

1) FROM 
2) SELECT 
3) DISTINCT
4) ORDER BY 

student_id	source_of_joining	enrollment_date
1	           Online	         2024-01-15
2		   Walk-in               2024-01-10
3	           Online	         2024-01-12
4	           Recommendation	 2024-01-14
5	           Walk-in	         2024-01-11
The DISTINCT operation will return the unique source_of_joining values: Online, Walk-in, and Recommendation.

For the Online group, you have two different enrollment_date values: 2024-01-12 and 2024-01-15.
For the Walk-in group, you have two different enrollment_date values: 2024-01-10 and 2024-01-11.
For the Recommendation group, there is only one enrollment_date: 2024-01-14.
SQL doesn’t know which enrollment_date to use for ordering each distinct source_of_joining, and it will throw an error.

⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐



___________________________________________________________________________________________________________________________________________________________________________________________



SESSION 8 -> AGGREGATE FUNCTIONS
________________________________


AGGREGATE FUNCTIONS :
_____________________

-> AGGREGATE FUNCTIONS IN SQL ARE USED TO PERFORM CALCULATIONS ON A 
   SET OF VALUES AND RETURN A SINGLE RESULT.



COUNT:
______

 select count(*) from students;
->THIS QUERY WILL RETURN THE TOTAL NUMBER OF ROWS (RECORDS) IN THE STUDENTS 
  TABLE. IT COUNTS EVERY ROW, INCLUDING ROWS WITH NULL VALUES IN ANY COLUMN.
+----------+
| count(*) |
+----------+
|        6 |
+----------+

select count(student_company) from students;
-> THIS QUERY WILL RETURN THE NUMBER OF ROWS IN THE STUDENTS TABLE WHERE 
   THE STUDENT_COMPANY COLUMN IS NOT NULL. IT WILL EXCLUDE ROWS WHERE STUDENT_COMPANY 
   HAS A NULL VALUE.


select count(DISTINCT student_company) from students;
+---------------------------------+
| count(DISTINCT student_company) |
+---------------------------------+
|                               4 |
+---------------------------------+

select count(DISTINCT student_company) as num_companies from students;
+---------------+
| num_companies |
+---------------+
|             4 |
+---------------+


select count(DISTINCT location) from students;
+--------------------------+
| count(DISTINCT location) |
+--------------------------+
|                        3 |
+--------------------------+

select count(DISTINCT source_of_joining) from students;
+-----------------------------------+
| count(DISTINCT source_of_joining) |
+-----------------------------------+
|                                 5 |
+-----------------------------------+

select count(*) from students where batch_date like '19%';
+----------+
| count(*) |
+----------+
|        3 |
+----------+


GROUP BY   VVIMP:
_________________


WHAT I WANT IS TO KNOW THAT HOW MANY PEOPLE HAVE JOINED MY COURSE THROUGH

LINKEDIN: 5
GOOGLE: 2
QUORA: 1

NEEDS TO GROUP BY SOURCE_OF_JOINING



 select source_of_joining, count(*) from students group by source_of_joining;
+-------------------+----------+
| source_of_joining | count(*) |
+-------------------+----------+
| friend            |        1 |
| google            |        1 |
| linkedin          |        1 |
| quora             |        1 |
| youtube           |        2 |
+-------------------+----------+
COUNT(*): THIS IS AN AGGREGATE FUNCTION THAT COUNTS THE NUMBER OF ROWS IN EACH GROUP. IT COUNTS HOW MANY STUDENTS BELONG TO EACH SOURCE_OF_JOINING.


select location, count(*) from students group by location;
+-----------+----------+
| location  | count(*) |
+-----------+----------+
| bangalore |        1 |
| chennai   |        2 |
| pune      |        3 |
+-----------+----------+
COUNT(*): THIS IS AN AGGREGATE FUNCTION THAT COUNTS THE NUMBER OF ROWS IN EACH GROUP. IT COUNTS HOW MANY STUDENTS BELONG TO EACH LOCATION.




⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐

select location, count(*) from students group by source_of_joining;
-> THIS WILL NOT WORK 

-> REASON : 
Why this query will not work:
The GROUP BY clause groups the results by the specified column(s), and in your query, you are grouping by source_of_joining.
However, in the SELECT clause, you are selecting the location column, which is not part of the GROUP BY clause.
In SQL, when using GROUP BY, all non-aggregated columns in the SELECT statement must be included in the GROUP BY clause. This is because SQL needs to know how to group all selected columns.

In your case:
location is not included in the GROUP BY clause, but it is being selected in the SELECT statement.
This causes SQL to be unable to determine how to handle the location column for each group formed by source_of_joining, resulting in an error.

When you use GROUP BY source_of_joining and select the location column in the SELECT clause, SQL encounters an issue because there could be multiple location values within each group formed by source_of_joining. SQL doesn't know which location to display in the result because it needs to have some rule to determine how to handle multiple location values within the same group.

SQL will encounter an issue because, for the Online group, there are multiple location values (New York, Boston, Chicago), and it won't know which one to show for that group.

⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐



 select location,source_of_joining,count(*) from students  group by location,source_of_joining;
+-----------+-------------------+----------+
| location  | source_of_joining | count(*) |
+-----------+-------------------+----------+
| bangalore | linkedin          |        1 |
| chennai   | google            |        1 |
| chennai   | quora             |        1 |
| pune      | friend            |        1 |
| pune      | youtube           |        2 |
+-----------+-------------------+----------+

 select selected_course, count(*) from students GROUP BY selected_course;
+-----------------+----------+
| selected_course | count(*) |
+-----------------+----------+
|               1 |        2 |
|               2 |        1 |
|               3 |        2 |
|               4 |        1 |
+-----------------+----------+

select batch_date,selected_course,count(*) from students GROUP BY batch_date,selected_course;
+------------+-----------------+----------+
| batch_date | selected_course | count(*) |
+------------+-----------------+----------+
| 05-02-2021 |               2 |        1 |
| 05-02-2021 |               3 |        1 |
| 05-02-2021 |               4 |        1 |
| 19-02-2021 |               1 |        2 |
| 19-02-2021 |               3 |        1 |
+------------+-----------------+----------+


SUM:
____

select source_of_joining, SUM(years_of_exp) from students group by source_of_joining;
+-------------------+-------------------+
| source_of_joining | sum(years_of_exp) |
+-------------------+-------------------+
| friend            |                15 |
| google            |                14 |
| linkedin          |                 6 |
| quora             |                 8 |
| youtube           |                38 |
+-------------------+-------------------+

AVG:
____

select source_of_joining, AVG(years_of_exp) from students group by source_of_joining;
+-------------------+-------------------+
| source_of_joining | avg(years_of_exp) |
+-------------------+-------------------+
| friend            |           15.0000 |
| google            |           14.0000 |
| linkedin          |            6.0000 |
| quora             |            8.0000 |
| youtube           |           19.0000 |
+-------------------+-------------------+


MIN & MAX:
__________

select MIN(years_of_exp) from students;
+-------------------+
| MIN(years_of_exp) |
+-------------------+
|                 6 |
+-------------------+

select MAX(years_of_exp) from students;
+-------------------+
| MAX(years_of_exp) |
+-------------------+
|                20 |
+-------------------+


⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐


***** select MIN(years_of_exp),student_fname from students;

-> THIS WILL NOT WORK
-> REASON : 
           
            This query will not work because you are trying to use an aggregate function MIN() on the column years_of_exp, but you are also selecting student_fname, a non-aggregated column. 
            In SQL, when you use aggregate functions like MIN(), MAX(), SUM(),etc., all other columns in the SELECT statement must either be aggregated or included in a GROUP BY clause.

student_fname	years_of_exp
John	            2
Alice	            3
Bob	            1
Charlie	            2

The minimum years_of_exp, which will return 1 (since 1 is the lowest value).
However, SQL doesn't know how to handle this query because it cannot determine which student_fname corresponds to the minimum years_of_exp



⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐



INSTEAD USE THIS 

MIN : select student_fname,years_of_exp from students order by years_of_exp limit 1;

MAX : select student_fname,years_of_exp from students order by years_of_exp desc limit 1;




EACH SOURCE OF JOINING I WANT TO GET MAX : 

select source_of_joining,MAX(years_of_exp) from students group by source_of_joining;
+-------------------+-------------------+
| source_of_joining | max(years_of_exp) |
+-------------------+-------------------+
| friend            |                15 |
| google            |                14 |
| linkedin          |                 6 |
| quora             |                 8 |
| youtube           |                20 |
+-------------------+-------------------+


___________________________________________________________________________________________________________________________________________________________________________________________



SESSION 9: -> DECIMAL & TIMESTAMPN DATATYPES
____________________________________________

create table courses_new
(
course_id int AUTO_INCREMENT,
course_name varchar(30) NOT NULL,
course_duration_months decimal(3,1) NOT NULL,
course_fee int NOT NULL,
PRIMARY KEY(course_id)
);



-> DECIMAL(3,1)
   3 UPTO 3 DIGITS
   1 DIGIT AFTER THE DECIMAL POINT



insert into courses_new(course_name,course_duration_months,course_fee) values
('bigdata', 6.5, 50000),
('webdevelopment', 3.5, 20000),
('datascience', 6, 40000);

update courses_new set course_fee = 40000 where course_id = 2;

select * from courses_new;
+-----------+----------------+------------------------+------------+
| course_id | course_name    | course_duration_months | course_fee |
+-----------+----------------+------------------------+------------+
|         1 | bigdata        |                    6.5 |      50000 |
|         2 | webdevelopment |                    3.5 |      40000 |
|         3 | datascience    |                    6.0 |      40000 |
+-----------+----------------+------------------------+------------+

create table courses_new
(
course_id int AUTO_INCREMENT,
course_name varchar(30) NOT NULL,
course_duration_months decimal(3,1) NOT NULL,
course_fee int NOT NULL,
changed_at TIMESTAMP DEFAULT NOW(),
PRIMARY KEY(course_id)
);


insert into courses_new(course_name,course_duration_months,course_fee) values
('bigdata', 6.5, 50000),
('webdevelopment', 3.5, 20000),
('datascience', 6, 40000),;

select * from courses_new;
+-----------+----------------+------------------------+------------+---------------------+
| course_id | course_name    | course_duration_months | course_fee | changed_at          |
+-----------+----------------+------------------------+------------+---------------------+
|         1 | bigdata        |                    6.5 |      50000 | 2022-07-11 00:01:52 |
|         2 | webdevelopment |                    3.5 |      20000 | 2022-07-11 00:01:52 |
|         3 | datascience    |                    6   |      40000 | 2022-07-11 00:01:52 |
+-----------+----------------+------------------------+------------+---------------------+

update courses_new set course_duration_months = 4.5 where course_id = 3;

select * from courses_new;
+-----------+----------------+------------------------+------------+---------------------+
| course_id | course_name    | course_duration_months | course_fee | changed_at          |
+-----------+----------------+------------------------+------------+---------------------+
|         1 | bigdata        |                    6.5 |      50000 | 2022-07-11 00:01:52 |
|         2 | webdevelopment |                    3.5 |      20000 | 2022-07-11 00:01:52 |
|         3 | datascience    |                    4.5 |      40000 | 2022-07-11 00:01:52 |
+-----------+----------------+------------------------+------------+---------------------+

WE HAVE UPDATED SOMETHING BUT THE TIME AT CHANGED_AT DID NOT CHANGED



create table courses_new
(
course_id int AUTO_INCREMENT,
course_name varchar(30) NOT NULL,
course_duration_months decimal(3,1) NOT NULL,
course_fee int NOT NULL,
changed_at TIMESTAMP DEFAULT NOW() ON UPDATE CURRENT_TIMESTAMP(),
PRIMARY KEY(course_id)
);

CURRENT_TIMESTAMP() AND NOW() BOTH ARE SAME

NOW IF WE UPDATE SOMETHING THEN THE TIME ALSO GETS CHANGED 

___________________________________________________________________________________________________________________________________________________________________________________________



SESSION 10:   -> LOGICAL OPERATORS
__________________________________

TO GET PEOPLE WHO ARE FROM BANGALORE:
select * from students where location = 'bangalore';


TO GET PEOPLE WHO ARE NOT FROM BANGALORE:
select * from students where location != 'bangalore';


GET ALL THE COURSES WHICH HAS WORD 'DATA'
select * from courses where course_name like "%data%";
+-----------+-------------+---------------------------+------------+
| course_id | course_name | course_duration_in_months | course_fee |
+-----------+-------------+---------------------------+------------+
|         1 | bigdata     |                         6 |      40000 |
|         3 | datascience |                         6 |      50000 |
|         5 | database    |                         4 |       3000 |
+-----------+-------------+---------------------------+------------+


GET ALL COURSES WHICH DO NOT HAVE THE WORD 'DATA'
select * from courses where course_name not like "%data%";
+-----------+----------------+---------------------------+------------+
| course_id | course_name    | course_duration_in_months | course_fee |
+-----------+----------------+---------------------------+------------+
|         2 | webdevelopment |                         3 |      20000 |
|         4 | devops         |                         1 |      10000 |
+-----------+----------------+---------------------------+------------+


ALL STUDENTS FROM BANGALORE WHO JOINED THROUGH LINKEDIN AND HAVING LESS THAN 8 YEARS OF EXPERIENCE.
select * from students where years_of_exp < 8  and source_of_joining = 'linkedin' and location='bangalore';


I WANT ALL PEOPLE WHO DO NOT FALL BETWEEN 8 TO 12 YEARS OF EXPERIENCE.
select * from students where years_of_exp<8 or years_of_exp>12;
select * from students where years_of_exp not between 8 and 12;


LIST OF STUDENTS FOR FLIPKART, WALMART, OR MICROSOFT.
select * from students where student_company='flipkart' or student_company='walmart' or student_company='microsoft';
select * from students where student_company in ('flipkart','walmart','microsoft');

select * from students where student_company not in ('flipkart','walmart','microsoft');


IF A COURSE IS MORE THAN 4 MONTHS, WE CATEGORIZE IT AS A MASTER'S PROGRAM; ELSE, IT IS A DIPLOMA PROGRAM.

select course_id,course_name,course_fee,
CASE
  WHEN course_duration_in_months > 4 THEN 'masters'
  ELSE 'diploma'
END as course_type 
from courses;

+-----------+----------------+------------+-------------+
| course_id | course_name    | course_fee | course_type |
+-----------+----------------+------------+-------------+
|         1 | bigdata        |      40000 | masters     |
|         2 | webdevelopment |      20000 | diploma     |
|         3 | datascience    |      50000 | masters     |
|         4 | devops         |      10000 | diploma     |
|         5 | database       |       3000 | diploma     |
+-----------+----------------+------------+-------------+


PEOPLE WORKING FOR WALMART, FLIPKART, AND MICROSOFT WE WANT TO SAY PRODUCT-BASED; ELSE, SERVICE-BASED.

select student_id,student_fname,student_lname,student_company,
CASE
  WHEN student_company in ('flipkart','walmart','microsoft') THEN 'product based'
  WHEN student_company is NULL THEN 'invalid company'
  ELSE 'service based'
END as company_type from students;

___________________________________________________________________________________________________________________________________________________________________________________________

SESSION 11 : -> JOINS
_____________________

-----
JOINS
-----


2 TABLES
--------
COURSES 
STUDENTS 


I WANT TO KNOW IN WHICH COURSE RAHUL HAS ENROLLED

STUDENTS -> RAHUL 1
--------

COURSES -> 1 BIG DATA
-------

select course_name from courses where course_id = (select selected_course from students where student_fname='rahul');
            +----------------+
            | course_name    |
            +----------------+
            | bigdata        |           
            +----------------+

IN STUDENTS TABLE WE HAVE SELECTED_COURSE
IN COURSES TABLE WE HAVE COURSE_ID


--> FIND THE COURSE IN WHICH STUDENTS ARE ENROLLED.

SELECT students.student_fname, students.student_lname,courses.course_name FROM students JOIN courses  
ON students.selected_course = courses.course_id;

** BY DEFAULT, IT IS AN INNER JOIN.
** INNER JOIN : ONLY THE MATCHING RECORDS WILL BE CONSIDERED AND NON-MATCHING RECORDS WILL BE DISCARDED.




---------------
LEFT OUTER JOIN
---------------

*** ALL THE MATCHING RECORDS FROM LEFT AND RIGHT TABLE ARE CONSIDERED + ALL THE NON-MATCHING RECORDS IN THE LEFT TABLE WHICH DOES NOT HAVE THE MATCH IN THE RIGHT TABLE PADDDED WITH NULL.

FOR LEFT OUTER JOIN TO HAPPEN, WE MUST HAVE SOME EXTRA RECORDS IN THE LEFT TABLE (T1)

T1 (LEFT TABLE) X T2 (RIGHT TABLE)

-- DELETE THE COURSE HAVING COURSE_ID = 2

DELETE FROM COURSES WHERE COURSE_ID = 2;
THE ABOVE DELETE QUERY WON'T WORK BECAUSE IT IS ATTACHED WITH THE STUDENTS TABLE ALSO IN THE FORM OF FOREIGN KEY
IF WE TRY TO DELETE THE COURSE HAVING COURSE_ID = 2, THEN THE STUDENT WHO HAS ENROLLED FOR COURSE_ID = 2 WILL BECOME INVALID
-- NOW, WE WILL CREATE A NEW STUDENTS TABLE AND A NEW COURSES TABLE WITH THE SAME DATA BUT THE FOREIGN KEY CONSTRAINT WON'T BE THERE
TO COPY A TABLE AND ITS STRUCTURE (BUT WITHOUT FOREIGN KEYS):
create table students_latest as select * from students;
create table courses_latest as select * from courses;

-- NOW, WE CAN DELETE THE RECORDS FROM THE COURSES TABLE


INNER JOIN
----------
SELECT students_latest.student_fname, students_latest.student_lname,courses_latest.course_name FROM students_latest JOIN courses_latest ON students_latest.selected_course = courses_latest.course_id;


LEFT OUTER JOIN
---------------
SELECT students_latest.student_fname, students_latest.student_lname,courses_latest.course_name FROM students_latest LEFT JOIN courses_latest ON students_latest.selected_course = courses_latest.course_id;




----------------
RIGHT OUTER JOIN
----------------


*** ALL THE MATCHING RECORDS FROM LEFT AND RIGHT TABLE ARE CONSIDERED +
ALL THE NON-MATCHING RECORDS IN THE RIGHT TABLE WHICH DO NOT HAVE A MATCH IN THE LEFT ARE PADDED WITH NULL

** FOR RIGHT OUTER JOIN TO HAPPEN, WE MUST HAVE SOME EXTRA RECORDS IN THE RIGHT TABLE (T2)

** T1 (LEFT TABLE) X T2 (RIGHT TABLE)
** HOW TO PERFORM A RIGHT OUTER JOIN?
==> WE JUST HAVE TO GIVE THE KEYWORD RIGHT BEFORE JOIN.

-- FIND THE COURSE IN WHICH STUDENTS ARE ENROLLED
SELECT students_latest.student_fname, students_latest.student_lname,courses_latest.course_name FROM students_latest RIGHT JOIN courses_latest ON students_latest.selected_course = courses_latest.course_id;



---------------
FULL OUTER JOIN
---------------


*ALL THE MATCHING RECORDS + NON-MATCHING RECORDS FROM LEFT + NON-MATCHING RECORDS FROM RIGHT

* FULL OUTER JOIN = LEFT OUTER JOIN UNION RIGHT OUTER JOIN
* IN SQL, WE DO NOT HAVE KEYWORD FULL FOR FULL OUTER JOIN, SO WE WILL DO UNION OF LEFT OUTER JOIN AND RIGHT OUTER JOIN

SELECT students_latest.student_fname, students_latest.student_lname,courses_latest.course_name FROM students_latest LEFT JOIN courses_latest ON students_latest.selected_course = courses_latest.course_id
UNION
SELECT students_latest.student_fname, students_latest.student_lname,courses_latest.course_name FROM students_latest RIGHT JOIN courses_latest ON students_latest.selected_course = courses_latest.course_id;




--------------------
CROSS JOIN   NOT IMP
--------------------

CROSS JOIN IN SQL RETURNS THE CARTESIAN PRODUCT OF TWO TABLES, MEANING IT COMBINES EACH 
RECORD FROM THE FIRST TABLE WITH EVERY RECORD FROM THE SECOND TABLE. IT DOES NOT REQUIRE 
A CONDITION OR ON CLAUSE.

THIS WILL RETURN ALL POSSIBLE COMBINATIONS OF STUDENTS AND COURSES.


IF LEFT TABLE (T1) HAS 4 RECORDS
IF RIGHT TABLE (T2) HAS 5 RECORDS

THEN, CROSS JOIN = 4 * 5 = 20 RECORDS, 1 TO 1 MAPPING WITH EACH RECORD.

SELECT COUNT(*) FROM students;
-- 7 RECORDS

SELECT COUNT(*) FROM courses;
-- 5 RECORDS

SELECT COUNT(*) FROM students, courses; 
-- 35 RECORDS

SELECT COUNT(*) FROM students JOIN courses;
-- 35 RECORDS


___________________________________________________________________________________________________________________________________________________________________________________________


SESSION 12 : -> WHERE vs HAVING CLAUSE IN SQL
_____________________________________________



-- FIND THE COUNT OF source_of_joining THROUGH WHICH STUDENT HAS ENROLLED
SELECT source_of_joining, COUNT(*) AS total from students GROUP BY source_of_joining;

-- FIND THE source_of_joining THROUGH WHICH MORE THAN 1 STUDENT HAS ENROLLED
SELECT source_of_joining, COUNT(*) AS total from students GROUP BY source_of_joining WHERE total > 1;
-> BUT THIS WILL NOT WORK

** WHERE CLAUSE IS USED TO FILTER THE INDIVIDUAL RECORDS BEFORE GROUP BY

SELECT source_of_joining, COUNT(*) AS total from students GROUP BY source_of_joining HAVING total > 1;

** HAVING CLAUSE IS USED TO FILTER THE RECORDS AFTER GROUP BY




-> WHERE
---------

product_id    amount
  1		200
  2		150
  1		100
  2		300
  1		250
 
EXAMPLE 1 : FILTERING INDIVIDUAL RECORDS WHERE AMOUNT > 150

product_id	amount
  2	         300
  1	         200
  1	         250



-> HAVING
---------

product_id    amount
  1		200
  2		150
  1		100
  2		300
  1		250

USING HAVING TO FILTER GROUPS BASED ON AGGREGATE VALUES
SUPPOSE YOU WANT TO FILTER THE GROUPS WHERE THE TOTAL SUM OF THE AMOUNT ARE GREATER THAN 500. YOU WOULD USE THE HAVING CLAUSE.


 product_id	total_sales
    1	          550






--  FIND THE TOTAL NUMBER OF STUDENTS WHO HAVE ENROLLED THROUGH LINKEDIN AS
source_of_joining


-- OPTIMISED QUERY (FILTERING IS HAPPENING BEFORE GROUP BY)
SELECT source_of_joining, COUNT(*) AS total FROM students WHERE source_of_joining = 'linkedin' GROUP BY source_of_joining;
-> OPTIMISED BECAUSE FIRST IT IS TAKING ALL THE STUDENTS WITH LINKEDIN THEN GROUPING 

OR

-- NON-OPTIMISED QUERY (FILTERING IS HAPPENING AFTER GROUP BY)
SELECT source_of_joining, COUNT(*) AS total FROM students GROUP BY source_of_joining HAVING source_of_joining = 'linkedin';
-> NON-OPTIMISED BECAUSE FIRST IT IS GROUPIING EVERYTHING THEN FROM THAT IT IS TAKING LINKEDIN MEMBER



----------------------------------------------------
CAN WE USE WHERE & HAVING CLAUSE IN THE SAME QUERY ?
----------------------------------------------------

-- FIND THE LOCATIONS FROM WHICH MORE THAN 1 STUDENT HAS JOINED & THE STUDENTS YEARS_OF_EXP IS MORE THAN 5 YEARS.

SELECT location, COUNT(*) AS total from students WHERE years_of_exp > 5 GROUP BY location HAVING total > 1;

________________________________________________________________________

★ WHERE IS USED BEFORE GROUP BY AND DOES FILTERING ON INDIVIDUAL RECORDS.
★ HAVING IS USED AFTER GROUP BY AND DOES FILTERING ON AGGREGATED RECORDS.
★ WE CAN USE WHERE AND HAVING IN THE SAME QUERY ALSO.
★ WHERE IS MORE PERFORMANT THAN HAVING.


___________________________________________________________________________________________________________________________________________________________________________________________


SESSION 13 : -> OVER AND PARTITION BY CLAUSE
____________________________________________



-- FROM HERE WE WON'T USE GOORM IDE, BECAUSE THAT WAS USING OLDER VERSIONS OF MYSQL. INSTEAD WE WILL USE   https://onecompiler.com/mysql

CREATE TABLE employee
(
    firstname varchar(20),
    lastname varchar(20),
    age int,
    salary int,
    location varchar(20)
);

INSERT INTO employee VALUES
('Sachin', 'Sharma', 28, 10000, 'Bangalore'),
('Rohit', 'Sharma', 30, 20000, 'Hyderabad'),
('Virat', 'Kohli', 29, 30000, 'Chennai'),
('Akshay', 'Kumar', 32, 40000, 'Bangalore'),
('Sunil', 'Shetty', 34, 50000, 'Hyderabad'),
('Mark', 'John', 34, 50000, 'Bangalore');

select * from employee;
+-----------+----------+------+--------+-----------+
| firstname | lastname | age  | salary | location  |
+-----------+----------+------+--------+-----------+
| Sachin    | Sharma   |   28 |  10000 | Bangalore |
| Rohit     | Sharma   |   30 |  20000 | Hyderabad |
| Virat     | Kohli    |   29 |  30000 | Chennai   |
| Akshay    | Kumar    |   32 |  40000 | Bangalore |
| Sunil     | Shetty   |   34 |  50000 | Hyderabad |
| Mark      | John     |   34 |  50000 | Bangalore |
+-----------+----------+------+--------+-----------+


-- HOW MANY PEOPLE ARE FROM EACH LOCATION AND AVERAGE SALARY AT EACH LOCATION.
-- BANGALORE, 4, 19999 (EXAMPLE)
SELECT location, COUNT(location) AS total, AVG(salary) AS average from employee GROUP BY location;
+-----------+-------+------------+
| location  | total | average    |
+-----------+-------+------------+
| Bangalore |     3 | 33333.3333 |
| Hyderabad |     2 | 35000.0000 |
| Chennai   |     1 | 30000.0000 |
+-----------+-------+------------+





-- FETCH THE FIRSTNAME, LASTNAME AND HOW MANY PEOPLE ARE FROM EACH LOCATION AND AVERAGE SALARY AT EACH LOCATION.
SELECT firstname, lastname, location, COUNT(location) AS total, AVG(salary) AS average from employee GROUP BY location;
-> IT WILL NOT WORK
REASON : 
-> firstname AND lastname ARE NOT AGGREGATED (LIKE USING COUNT, AVG, ETC.) NOR PART OF THE GROUP BY CLAUSE, 
   SO SQL DOESNOT KNOW HOW TO HANDLE THEM WHEN GROUPING BY LOCATION.


-- WE CAN TRY ACHIEVEING IT USING A JOIN

SELECT firstname, lastname, employee.location, total_count, avg_salary FROM employee JOIN 
(SELECT location, COUNT(location) AS total_count, AVG(salary) AS avg_salary from employee GROUP BY location) temptable ON 
employee.location = temptable.location;
*** -> Q) WHY employee.location ? ANS) THE LOCATION COLUMN WHICH WE ARE SELETCING
     IT BELONGS TO EMPLOYEE TABLE  AND TEMPTABLE ALSO SO SYSTEM WILL CONFUSE
     SO.... WE HAVE TO GIVE LIKE THAT AND WE CAN ALSO WRITE LIKE THIS 
SELECT firstname, lastname, temptable.location, total_count, avg_salary FROM employee JOIN 
(SELECT location, COUNT(location) AS total_count, AVG(salary) AS avg_salary from employee GROUP BY location) temptable ON 
employee.location = temptable.location;

EMPLOYEE: THE ACTUAL TABLE IN THE DATABASE.
TEMPTABLE: AN ALIAS FOR THE RESULT SET OF THE SUBQUERY, USED TO JOIN AGGREGATED DATA (LIKE COUNT AND AVERAGE) BACK WITH THE ORIGINAL EMPLOYEE TABLE.

THE QUERY RETRIEVES EACH EMPLOYEE'S DETAILS (FIRSTNAME, LASTNAME, LOCATION) AND ADDS THE TOTAL NUMBER OF EMPLOYEES (TOTAL_COUNT) AND AVERAGE SALARY (AVG_SALARY) FOR THEIR LOCATION BY JOINING WITH A SUBQUERY THAT CALCULATES THESE AGGREGATES.

+-----------+----------+-----------+-------------+------------+
| firstname | lastname | location  | total_count | avg_salary |
+-----------+----------+-----------+-------------+------------+
| Sachin    | Sharma   | Bangalore |           3 | 33333.3333 |
| Rohit     | Sharma   | Hyderabad |           2 | 35000.0000 |
| Virat     | Kohli    | Chennai   |           1 | 30000.0000 |
| Akshay    | Kumar    | Bangalore |           3 | 33333.3333 |
| Sunil     | Shetty   | Hyderabad |           2 | 35000.0000 |
| Mark      | John     | Bangalore |           3 | 33333.3333 |
+-----------+----------+-----------+-------------+------------+



-- IS THERE ANY OTHER WAY TO PERFORM ABOVE QUERY?

==> WE CAN USE OVER PARTITION BY TO ACHIEVE THIS EASILY

** PARTITION BY IS USEFUL WHILE PERFORMING OPERATIONS ON NON-AGGREGATE COLUMNS

SELECT firstname, lastname, location, 
COUNT(location) OVER (PARTITION BY location) AS total, 
AVG(salary) OVER (PARTITION BY location) AS average 
FROM employee;

+-----------+----------+-----------+-------+------------+
| firstname | lastname | location  | total | average    |
+-----------+----------+-----------+-------+------------+
| Sachin    | Sharma   | Bangalore |     3 | 33333.3333 |
| Akshay    | Kumar    | Bangalore |     3 | 33333.3333 |
| Mark      | John     | Bangalore |     3 | 33333.3333 |
| Virat     | Kohli    | Chennai   |     1 | 30000.0000 |
| Rohit     | Sharma   | Hyderabad |     2 | 35000.0000 |
| Sunil     | Shetty   | Hyderabad |     2 | 35000.0000 |
+-----------+----------+-----------+-------+------------+

___________________________________________________________________________________________________________________________________________________________________________________________


SESSION 14 : -> ROW NUMBER FUNCTION
___________________________________



CREATE TABLE employee
(
    firstname varchar(20),
    lastname varchar(20),
    age int,
    salary int,
    location varchar(20)
);

INSERT INTO employee VALUES
('Sachin', 'Sharma', 28, 10000, 'Bangalore'),
('Shane', 'Warne', 30, 20000, 'Bangalore'),
('Rohit', 'Sharma', 32, 30000, 'Hyderabad'),
('Shikhar', 'Dhawan', 32, 25000, 'Hyderabad'),
('Rahul', 'Dravid', 31, 20000, 'Bangalore'),
('Saurabh', 'Ganguly', 32, 15000, 'Pune'),
('Kapil', 'Dev', 34, 10000, 'Pune');


===============================================================================

** ROW_NUMBER() WON'T WORK without ORDER BY 

SELECT firstname, lastname, salary, 
row_number() OVER (ORDER BY salary DESC) FROM employee;

OVER DEFINES HOW TO APPLY ROW_NUMBER(), LIKE SAYING "RANK THESE ROWS BASED ON SALARY".
WITHOUT OVER, SQL DOESN'T KNOW HOW TO RANK OR ASSIGN ROW NUMBERS AND WILL PRODUCE AN ERROR.
THE ROW_NUMBER() FUNCTION REQUIRES OVER TO TELL IT HOW TO ASSIGN THE NUMBERS

+-----------+----------+--------+------------------------------------------+
| firstname | lastname | salary | row_number() OVER (ORDER BY salary DESC) |
+-----------+----------+--------+------------------------------------------+
| Rohit     | Sharma   |  30000 |                                        1 |
| Shikhar   | Dhawan   |  25000 |                                        2 |
| Shane     | Warne    |  20000 |                                        3 |
| Rahul     | Dravid   |  20000 |                                        4 |
| Saurabh   | Ganguly  |  15000 |                                        5 |
| Sachin    | Sharma   |  10000 |                                        6 |
| Kapil     | Dev      |  10000 |                                        7 |
+-----------+----------+--------+------------------------------------------+

SELECT firstname, lastname, salary, 
row_number() OVER (ORDER BY salary DESC) as RowNumber FROM employee;
+-----------+----------+--------+-----------+
| firstname | lastname | salary | RowNumber |
+-----------+----------+--------+-----------+
| Rohit     | Sharma   |  30000 |         1 |
| Shikhar   | Dhawan   |  25000 |         2 |
| Shane     | Warne    |  20000 |         3 |
| Rahul     | Dravid   |  20000 |         4 |
| Saurabh   | Ganguly  |  15000 |         5 |
| Sachin    | Sharma   |  10000 |         6 |
| Kapil     | Dev      |  10000 |         7 |
+-----------+----------+--------+-----------+



-- FIND THE RECORD HAVING 5TH HIGHEST SALARY

select * from (select firstname, lastname, salary, 
row_number() over (order by salary desc) AS rownum from employee) temptable where rownum = 5;

TEMPTABLE IS AN ALIAS FOR THE RESULT SET GENERATED BY THE INNER QUERY. IT IS NOT A PHYSICAL 
TABLE IN THE DATABASE; RATHER, IT REPRESENTS A TEMPORARY VIEW OF THE DATA PRODUCED BY THE INNER QUERY.

+-----------+----------+--------+--------+
| firstname | lastname | salary | rownum |
+-----------+----------+--------+--------+
| Saurabh   | Ganguly  |  15000 |      5 |
+-----------+----------+--------+--------+


-- ASSIGN ROW NUMBER FOR PARTITIONS BASED ON EACH LOCATION

SELECT firstname, lastname, location, salary, row_number() OVER (PARTITION BY location ORDER BY salary DESC) FROM employee; 
+-----------+----------+-----------+--------+----------------------------------------------------------------+
| firstname | lastname | location  | salary | row_number() OVER (PARTITION BY location ORDER BY salary DESC) |
+-----------+----------+-----------+--------+----------------------------------------------------------------+
| Shane     | Warne    | Bangalore |  20000 |                                                              1 |
| Rahul     | Dravid   | Bangalore |  20000 |                                                              2 |
| Sachin    | Sharma   | Bangalore |  10000 |                                                              3 |
| Rohit     | Sharma   | Hyderabad |  30000 |                                                              1 |
| Shikhar   | Dhawan   | Hyderabad |  25000 |                                                              2 |
| Saurabh   | Ganguly  | Pune      |  15000 |                                                              1 |
| Kapil     | Dev      | Pune      |  10000 |                                                              2 |
+-----------+----------+-----------+--------+----------------------------------------------------------------+


-- FIND THE CANDIDATE HAVING HIGHEST SALARY FROM EACH LOCATION

SELECT * FROM (SELECT firstname, lastname, location, salary, 
row_number() OVER (PARTITION BY location ORDER BY salary DESC) AS rownum 
FROM employee) temptable
WHERE rownum = 1;
+-----------+----------+-----------+--------+--------+
| firstname | lastname | location  | salary | rownum |
+-----------+----------+-----------+--------+--------+
| Shane     | Warne    | Bangalore |  20000 |      1 |
| Rohit     | Sharma   | Hyderabad |  30000 |      1 |
| Saurabh   | Ganguly  | Pune      |  15000 |      1 |
+-----------+----------+-----------+--------+--------+


===============================================================================

** WHEN WE USE ROW_NUMBER, WE MUST USE ORDER BY CLAUSE OTHERWISE IT WON'T WORK.
** WHEN WE USE ROW_NUMBER, WE MAY/MAY NOT USE THE PARTITION BY.
** THE ROW_NUMBER STARTS FROM 1 FOR EACH PARTITION.
** ROW_NUMBER WILL ASSIGN THE NUMBER UNIQUELY EVEN THOUGH THERE ARE DUPLICATE DATA IN THE RECORDS.


___________________________________________________________________________________________________________________________________________________________________________________________


SESSION 15 : -> RANK & DENSE RANK
_________________________________


CREATE TABLE employee
(
    firstname varchar(20),
    lastname varchar(20),
    age int,
    salary int,
    location varchar(20)
);

INSERT INTO employee VALUES
('Sachin', 'Sharma', 28, 10000, 'Bangalore'),
('Shane', 'Warne', 30, 20000, 'Bangalore'),
('Rohit', 'Sharma', 32, 30000, 'Hyderabad'),
('Shikhar', 'Dhawan', 32, 25000, 'Hyderabad'),
('Rahul', 'Dravid', 31, 20000, 'Bangalore'),
('Saurabh', 'Ganguly', 32, 15000, 'Pune'),
('Kapil', 'Dev', 34, 10000, 'Pune');

--------------------------------------------------------------------------

** LIKE IN ROW_NUMBER, ORDER BY IS MANDATORY FOR RANK & DENSE_RANK
** ROW_NUMBER DO NOT HANDLES DUPLICATES, SO WE HAVE RANK & DENSE RANK
** WHEN THERE ARE NO DUPLICATE DATA IN THE RECORDS, ROW_NUMBER(), RANK() AND DENSE_RANK()            
   ALL OF THEM WILL GIVE THE SAME RESULT.    


SELECT firstname, lastname, salary, 
row_number() OVER (ORDER BY salary DESC) FROM employee;
+-----------+----------+--------+------------------------------------------+
| firstname | lastname | salary | row_number() OVER (ORDER BY salary DESC) |
+-----------+----------+--------+------------------------------------------+
| Rohit     | Sharma   |  30000 |                                        1 |
| Shikhar   | Dhawan   |  25000 |                                        2 |
| Shane     | Warne    |  20000 |                                        3 |
| Rahul     | Dravid   |  20000 |                                        4 |
| Saurabh   | Ganguly  |  15000 |                                        5 |
| Sachin    | Sharma   |  10000 |                                        6 |
| Kapil     | Dev      |  10000 |                                        7 |
+-----------+----------+--------+------------------------------------------+
EACH ROW GETS A UNIQUE RANK, EVEN IF THERE ARE DUPLICATE VALUES IN THE COLUMN(S)
NO GAPS IN NUMBERING.


SELECT firstname, lastname, salary, 
RANK() OVER (ORDER BY salary DESC) FROM employee;
+-----------+----------+--------+------------------------------------+
| firstname | lastname | salary | RANK() OVER (ORDER BY salary DESC) |
+-----------+----------+--------+------------------------------------+
| Rohit     | Sharma   |  30000 |                                  1 |
| Shikhar   | Dhawan   |  25000 |                                  2 |
| Shane     | Warne    |  20000 |                                  3 |
| Rahul     | Dravid   |  20000 |                                  3 |
| Saurabh   | Ganguly  |  15000 |                                  5 |
| Sachin    | Sharma   |  10000 |                                  6 |
| Kapil     | Dev      |  10000 |                                  6 |
+-----------+----------+--------+------------------------------------+
ROWS WITH THE SAME VALUE RECEIVE THE SAME RANK.
GAPS APPEAR IN THE RANKING IF DUPLICATE VALUES EXIST.


SELECT firstname, lastname, salary, 
DENSE_RANK() OVER (ORDER BY salary DESC) FROM employee;
+-----------+----------+--------+------------------------------------------+
| firstname | lastname | salary | DENSE_RANK() OVER (ORDER BY salary DESC) |
+-----------+----------+--------+------------------------------------------+
| Rohit     | Sharma   |  30000 |                                        1 |
| Shikhar   | Dhawan   |  25000 |                                        2 |
| Shane     | Warne    |  20000 |                                        3 |
| Rahul     | Dravid   |  20000 |                                        3 |
| Saurabh   | Ganguly  |  15000 |                                        4 |
| Sachin    | Sharma   |  10000 |                                        5 |
| Kapil     | Dev      |  10000 |                                        5 |
+-----------+----------+--------+------------------------------------------+
ROWS WITH THE SAME VALUE RECEIVE THE SAME RANK.
THE NEXT RANK INCREMENTS BY 1, EVEN IF THERE ARE DUPLICATES.






====================================================================

WHEN SHOULD WE USE THE DENSE_RANK()?

-- CONSIDER THE USECASE WHEN WE HAVE TO FIND THE TOP 3 POSITIONS IN 
   SOME COMPETITION, THEN AS PER DENSE_RANK(), WE WILL HAVE THE
   BELOW RANKS.  

CANDIDATE 1 SCORE = 100 ==> 1
CANDIDATE 2 SCORE = 100 ==> 1
CANDIDATE 3 SCORE = 98  ==> 2
CANDIDATE 4 SCORE = 97  ==> 3
CANDIDATE 5 SCORE = 97  ==> 3
CANDIDATE 6 SCORE = 96  ==> 4


-- FIND THE PERSON HAVING RANK = 4

SELECT * FROM (SELECT firstname, lastname, salary, 
DENSE_RANK() OVER (ORDER BY salary DESC) AS rownum from employee) temptable WHERE rownum = 4;


___________________________________________________________________________________________________________________________________________________________________________________________
 
!=    AND     NOT IN    🔥

IMP TIPS & TRICKS 
_________________

-> TO GET THE LENGTH OF A STRING USE LENGTH(STRING NAME)
-> THE ( IS NULL ) COMMAND IS USED TO TEST FOR EMPTY VALUES (NULL VALUES).
-> THE ( IS NOT NULL ) COMMAND IS USED TO TEST FOR NON-EMPTY VALUES (NOT NULL values).
-> REPLACE(STRING, OLD_SUBSTRING, NEW_SUBSTRING)





-> THE DIFFERENCE BETWEEN ISNULL AND IFNULL
   In MySQL, ISNULL and IFNULL are both used to handle NULL values, but they are used in different contexts and have different syntax and purposes:

ISNULL():

SELECT ISNULL(column_name) FROM table_name;
This will return 1 if column_name is NULL, and 0 if it is not NULL.


IFNULL():

SELECT IFNULL(column_name, 'Default Value') FROM table_name;
This will return 'Default Value' if column_name is NULL, and return the value of column_name if it is not NULL.
   





-> DIFFERENCE BETWEEN COUNT(*),COUNT(COLUMNNAME),COUNT(DISTINCT COLUMNNAME)
   COUNT(*) WILL GIVE THE NUMBER OF ROWS IN A TABLE  
   COUNT(COLUMNNAME) WILL GIVE THE NUMBER OF ROWS IN A TABLE BUT IF THE VALUE IN A ROW IS NULL IT WON'T COUNT  
   COUNT(DISTINCT COLUMNNAME) IT WILL GIVE DISTINCT NUMBER OF ROWS IN A TABLE BUT IF THE VALUE IN A ROW IS NULL IT WON'T COUNT  

-> PATTERN MATCHING IN SQL WITH LIKE OPERATOR
   % ALREADY DONE 
   - ALREADY DONE
   [] ANYTHING WITHIN BRACKETS CAN COME
   EXAMPLE : 'A[NP]%'
              ANASDV ✓ 
              APDFBF ✓ 
              AADFSG ✘ 
   [^] ANYTHING EXCEPT (WITHIN BRACKETS) CAN COME
   EXAMPLE : 'A[^NP]%'
              ANASDV ✘ 
              APDFBF ✘  
              AADFSG ✓ 
   [-]
   EXAMPLE : 'A[A-D]%'
              AAASDV ✓ 
              ACDFBF ✓ 
              AZDFSG ✘

-> UPPERCASE,LOWERCASE,SUBSTRING,CONCATENATE

UPPERCASE   : 
             UPPER('hello world')
LOWERCASE   : 
             LOWER('HELLO WORLD')
SUBSTRING   : 
             SUBSTRING(STRING, START, LENGTH)
             STARTING POSITION (1 - BASED)
             LENGTH IN OPTIONAL
CONCATENATE : 
             CONCAT(STRING1, STRING2, ...)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-> MEAN 	: AVERAGE OF ALL VALUES	
   MEDIAN	: MIDDLE VALUE	
   MODE 	: MOST FREQUENT VALUE

-> TO CALCULATE MEAN WE CAN USE AVG() FUNCTION    
-> TO CALCULATE MEDIAN  - MEDIAN USING ROW_NUMBER
   

CREATE TABLE employee 
(
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    department_id INT,
    salary INT,
    manager_id INT,
    emp_age INT
);

INSERT INTO employee (emp_id, emp_name, department_id, salary, manager_id, emp_age) VALUES
(8, 'Ashish', 200, 5000, 2, 12),
(7, 'Sanjay', 200, 9000, 2, 13),
(6, 'Agam', 200, 12000, 2, 14),
(4, 'Rohit', 100, 5000, 2, 16),
(3, 'Vikas', 100, 10000, 4, 37),
(1, 'Ankit', 100, 10000, 4, 39),
(2, 'Mohit', 100, 15000, 4, 48),
(9, 'Mukesh', 300, 6000, 6, 51),
(5, 'Mudit', 200, 12000, 6, 55);


select *
,row_number() over(order by emp_age asc) as rn_asc
,row_number() over(order by emp_age desc) as rn_desc
from employee
order by emp_age;

+--------+----------+---------------+--------+------------+---------+--------+---------+
| emp_id | emp_name | department_id | salary | manager_id | emp_age | rn_asc | rn_desc |
+--------+----------+---------------+--------+------------+---------+--------+---------+
|      8 | Ashish   |           200 |   5000 |          2 |      12 |      1 |       9 |
|      7 | Sanjay   |           200 |   9000 |          2 |      13 |      2 |       8 |
|      6 | Agam     |           200 |  12000 |          2 |      14 |      3 |       7 |
|      4 | Rohit    |           100 |   5000 |          2 |      16 |      4 |       6 |
|      3 | Vikas    |           100 |  10000 |          4 |      37 |      5 |       5 |
|      1 | Ankit    |           100 |  10000 |          4 |      39 |      6 |       4 |
|      2 | Mohit    |           100 |  15000 |          4 |      48 |      7 |       3 |
|      9 | Mukesh   |           300 |   6000 |          6 |      51 |      8 |       2 |
|      5 | Mudit    |           200 |  12000 |          6 |      55 |      9 |       1 |
+--------+----------+---------------+--------+------------+---------+--------+---------+



select *
,row_number() over(order by emp_age asc) as rn_asc
,row_number() over(order by emp_age desc) as rn_desc
from employee
order by emp_age desc;

+--------+----------+---------------+--------+------------+---------+--------+---------+
| emp_id | emp_name | department_id | salary | manager_id | emp_age | rn_asc | rn_desc |
+--------+----------+---------------+--------+------------+---------+--------+---------+
|      5 | Mudit    |           200 |  12000 |          6 |      55 |      9 |       1 |
|      9 | Mukesh   |           300 |   6000 |          6 |      51 |      8 |       2 |
|      2 | Mohit    |           100 |  15000 |          4 |      48 |      7 |       3 |
|      1 | Ankit    |           100 |  10000 |          4 |      39 |      6 |       4 |
|      3 | Vikas    |           100 |  10000 |          4 |      37 |      5 |       5 |
|      4 | Rohit    |           100 |   5000 |          2 |      16 |      4 |       6 |
|      6 | Agam     |           200 |  12000 |          2 |      14 |      3 |       7 |
|      7 | Sanjay   |           200 |   9000 |          2 |      13 |      2 |       8 |
|      8 | Ashish   |           200 |   5000 |          2 |      12 |      1 |       9 |
+--------+----------+---------------+--------+------------+---------+--------+---------+




CREATE TABLE employee 
(
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    department_id INT,
    salary INT,
    manager_id INT,
    emp_age INT
);

INSERT INTO employee (emp_id, emp_name, department_id, salary, manager_id, emp_age) VALUES
(8, 'Ashish', 200, 5000, 2, 12),
(7, 'Sanjay', 200, 9000, 2, 13),
(6, 'Agam', 200, 12000, 2, 14),
(4, 'Rohit', 100, 5000, 2, 16),
(3, 'Vikas', 100, 10000, 4, 37),
(1, 'Ankit', 100, 10000, 4, 39),
(2, 'Mohit', 100, 15000, 4, 48),
(9, 'Mukesh', 300, 6000, 6, 51),
(5, 'Mudit', 200, 12000, 6, 55),
(10,'Rakesh', 300, 7000, 6, 50);



select *
,row_number() over(order by emp_age asc) as rn_asc
,row_number() over(order by emp_age desc) as rn_desc
from employee
order by emp_age;

+--------+----------+---------------+--------+------------+---------+--------+---------+
| emp_id | emp_name | department_id | salary | manager_id | emp_age | rn_asc | rn_desc |
+--------+----------+---------------+--------+------------+---------+--------+---------+
|      8 | Ashish   |           200 |   5000 |          2 |      12 |      1 |      10 |
|      7 | Sanjay   |           200 |   9000 |          2 |      13 |      2 |       9 |
|      6 | Agam     |           200 |  12000 |          2 |      14 |      3 |       8 |
|      4 | Rohit    |           100 |   5000 |          2 |      16 |      4 |       7 |
|      3 | Vikas    |           100 |  10000 |          4 |      37 |      5 |       6 |
|      1 | Ankit    |           100 |  10000 |          4 |      39 |      6 |       5 |
|      2 | Mohit    |           100 |  15000 |          4 |      48 |      7 |       4 |
|     10 | Rakesh   |           300 |   7000 |          6 |      50 |      8 |       3 |
|      9 | Mukesh   |           300 |   6000 |          6 |      51 |      9 |       2 |
|      5 | Mudit    |           200 |  12000 |          6 |      55 |     10 |       1 |
+--------+----------+---------------+--------+------------+---------+--------+---------+

select *
,row_number() over(order by emp_age asc) as rn_asc
,row_number() over(order by emp_age desc) as rn_desc
from employee
order by emp_age desc;

+--------+----------+---------------+--------+------------+---------+--------+---------+
| emp_id | emp_name | department_id | salary | manager_id | emp_age | rn_asc | rn_desc |
+--------+----------+---------------+--------+------------+---------+--------+---------+
|      5 | Mudit    |           200 |  12000 |          6 |      55 |     10 |       1 |
|      9 | Mukesh   |           300 |   6000 |          6 |      51 |      9 |       2 |
|     10 | Rakesh   |           300 |   7000 |          6 |      50 |      8 |       3 |
|      2 | Mohit    |           100 |  15000 |          4 |      48 |      7 |       4 |
|      1 | Ankit    |           100 |  10000 |          4 |      39 |      6 |       5 |
|      3 | Vikas    |           100 |  10000 |          4 |      37 |      5 |       6 |
|      4 | Rohit    |           100 |   5000 |          2 |      16 |      4 |       7 |
|      6 | Agam     |           200 |  12000 |          2 |      14 |      3 |       8 |
|      7 | Sanjay   |           200 |   9000 |          2 |      13 |      2 |       9 |
|      8 | Ashish   |           200 |   5000 |          2 |      12 |      1 |      10 |
+--------+----------+---------------+--------+------------+---------+--------+---------+


-> ***** 
   THE WITH CLAUSE IN SQL IS USED TO DEFINE A COMMON TABLE EXPRESSION (CTE), WHICH IS LIKE A TEMPORARY RESULT SET OR TABLE.

with cte as (select *
,row_number() over(order by emp_age asc) as rn_asc
,row_number() over(order by emp_age desc) as rn_desc
from employee
)
select avg(emp_age) from cte
where abs(rn_asc - rn_desc) <=1;

OUTPUT : 38



with cte as (select *
,row_number() over(order by emp_age asc) as rn_asc
,row_number() over(order by emp_age desc) as rn_desc
from employee
where emp_id < 10
)
select avg(emp_age) from cte
where abs(rn_asc - rn_desc) <=1;

OUTPUT : 37



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-> TO CALCULATE MODE


create table employee
(
  id int
);
insert into employee values(1),(2),(2),(3),(3),(3),(3),(4),(5);
select * from employee;
+------+
| id   |
+------+
|    1 |
|    2 |
|    2 |
|    3 |
|    3 |
|    3 |
|    3 |
|    4 |
|    5 |
+------+

METHOD 1 : 
   
select id,count(*) as freq from employee group by id;
+------+------+
| id   | freq |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    4 |
|    4 |    1 |
|    5 |    1 |
+------+------+

with freq_cte as (select id,count(*) as freq from employee group by id)
select max(freq) from freq_cte;

OUTPUT : 4

with freq_cte as (select id,count(*) as freq from employee group by id)
select * from freq_cte
where freq = (select max(freq) from freq_cte);

OUTPUT :

+------+------+
| id   | freq |
+------+------+
|    3 |    4 |
+------+------+



create table employee
(
  id int
);
insert into employee values(1),(2),(2),(3),(3),(3),(3),(4),(5),(4),(4),(4);

with freq_cte as (select id,count(*) as freq from employee group by id)
select * from freq_cte
where freq = (select max(freq) from freq_cte);
+------+------+
| id   | freq |
+------+------+
|    3 |    4 |
|    4 |    4 |
+------+------+




METHOD 2 : 

with freq_cte as (select id,count(*) as freq from employee group by id),rnk_cte as (select *,rank() over(order by freq desc) as rn from freq_cte)
select * from rnk_cte where rn = 1;

+------+------+----+
| id   | freq | rn |
+------+------+----+
|    3 |    4 |  1 |
|    4 |    4 |  1 |
+------+------+----+

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


SQL AGGREGATIONS ZERO TO HERO 

CREATE TABLE sales 
(
    salesperson_id INT,
    order_number INT,
    order_date DATE,
    amount INT
);

INSERT INTO sales (salesperson_id, order_number, order_date, amount) VALUES
(1, 30, '1995-07-14', 460),
(7, 50, '1998-02-03', 600),
(2, 40, '1998-01-29', 2400),
(7, 60, '1998-03-02', 720),
(2, 10, '1996-08-02', 540),
(7, 70, '1998-05-06', 150),
(8, 20, '1999-01-30', 1800);

select salesperson_id,order_number,order_date,amount,sum(amount) over() from sales;

+----------------+--------------+------------+--------+--------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over() |
+----------------+--------------+------------+--------+--------------------+
|              1 |           30 | 1995-07-14 |    460 |               6670 |
|              7 |           50 | 1998-02-03 |    600 |               6670 |
|              2 |           40 | 1998-01-29 |   2400 |               6670 |
|              7 |           60 | 1998-03-02 |    720 |               6670 |
|              2 |           10 | 1996-08-02 |    540 |               6670 |
|              7 |           70 | 1998-05-06 |    150 |               6670 |
|              8 |           20 | 1999-01-30 |   1800 |               6670 |
+----------------+--------------+------------+--------+--------------------+




select salesperson_id,order_number,order_date,amount,sum(amount) over(partition by salesperson_id) from sales;

+----------------+--------------+------------+--------+-----------------------------------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over(partition by salesperson_id) |
+----------------+--------------+------------+--------+-----------------------------------------------+
|              1 |           30 | 1995-07-14 |    460 |                                           460 |
|              2 |           40 | 1998-01-29 |   2400 |                                          2940 |
|              2 |           10 | 1996-08-02 |    540 |                                          2940 |
|              7 |           50 | 1998-02-03 |    600 |                                          1470 |
|              7 |           60 | 1998-03-02 |    720 |                                          1470 |
|              7 |           70 | 1998-05-06 |    150 |                                          1470 |
|              8 |           20 | 1999-01-30 |   1800 |                                          1800 |
+----------------+--------------+------------+--------+-----------------------------------------------+




select salesperson_id,order_number,order_date,amount,sum(amount) over(order by order_date) from sales;

+----------------+--------------+------------+--------+---------------------------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over(order by order_date) |
+----------------+--------------+------------+--------+---------------------------------------+
|              1 |           30 | 1995-07-14 |    460 |                                   460 |
|              2 |           10 | 1996-08-02 |    540 |                                  1000 |
|              2 |           40 | 1998-01-29 |   2400 |                                  3400 |
|              7 |           50 | 1998-02-03 |    600 |                                  4000 |
|              7 |           60 | 1998-03-02 |    720 |                                  4720 |
|              7 |           70 | 1998-05-06 |    150 |                                  4870 |
|              8 |           20 | 1999-01-30 |   1800 |                                  6670 |
+----------------+--------------+------------+--------+---------------------------------------+




select salesperson_id,order_number,order_date,amount,sum(amount) over(partition by salesperson_id order by order_date) from sales;

+----------------+--------------+------------+--------+-------------------------------------------------------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over(partition by salesperson_id order by order_date) |
+----------------+--------------+------------+--------+-------------------------------------------------------------------+
|              1 |           30 | 1995-07-14 |    460 |                                                               460 |
|              2 |           10 | 1996-08-02 |    540 |                                                               540 |
|              2 |           40 | 1998-01-29 |   2400 |                                                              2940 |
|              7 |           50 | 1998-02-03 |    600 |                                                               600 |
|              7 |           60 | 1998-03-02 |    720 |                                                              1320 |
|              7 |           70 | 1998-05-06 |    150 |                                                              1470 |
|              8 |           20 | 1999-01-30 |   1800 |                                                              1800 |
+----------------+--------------+------------+--------+-------------------------------------------------------------------+




select salesperson_id,order_number,order_date,amount,sum(amount) over(order by order_date rows between 2 preceding and current row) from sales;

+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over(order by order_date rows between 2 preceding and current row) |
+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+
|              1 |           30 | 1995-07-14 |    460 |                                                                            460 |
|              2 |           10 | 1996-08-02 |    540 |                                                                           1000 |
|              2 |           40 | 1998-01-29 |   2400 |                                                                           3400 |
|              7 |           50 | 1998-02-03 |    600 |                                                                           3540 |
|              7 |           60 | 1998-03-02 |    720 |                                                                           3720 |
|              7 |           70 | 1998-05-06 |    150 |                                                                           1470 |
|              8 |           20 | 1999-01-30 |   1800 |                                                                           2670 |
+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+





select salesperson_id,order_number,order_date,amount,sum(amount) over(order by order_date rows between 2 preceding and 1 preceding) from sales;

+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over(order by order_date rows between 2 preceding and 1 preceding) |
+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+
|              1 |           30 | 1995-07-14 |    460 |                                                                           NULL |
|              2 |           10 | 1996-08-02 |    540 |                                                                            460 |
|              2 |           40 | 1998-01-29 |   2400 |                                                                           1000 |
|              7 |           50 | 1998-02-03 |    600 |                                                                           2940 |
|              7 |           60 | 1998-03-02 |    720 |                                                                           3000 |
|              7 |           70 | 1998-05-06 |    150 |                                                                           1320 |
|              8 |           20 | 1999-01-30 |   1800 |                                                                            870 |
+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+





select salesperson_id,order_number,order_date,amount,sum(amount) over(order by order_date rows between 1 preceding and 1 following) from sales;

+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over(order by order_date rows between 1 preceding and 1 following) |
+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+
|              1 |           30 | 1995-07-14 |    460 |                                                                           1000 |
|              2 |           10 | 1996-08-02 |    540 |                                                                           3400 |
|              2 |           40 | 1998-01-29 |   2400 |                                                                           3540 |
|              7 |           50 | 1998-02-03 |    600 |                                                                           3720 |
|              7 |           60 | 1998-03-02 |    720 |                                                                           1470 |
|              7 |           70 | 1998-05-06 |    150 |                                                                           2670 |
|              8 |           20 | 1999-01-30 |   1800 |                                                                           1950 |
+----------------+--------------+------------+--------+--------------------------------------------------------------------------------+








select salesperson_id,order_number,order_date,amount,sum(amount) over(order by order_date rows between unbounded preceding and current row) from sales;


+----------------+--------------+------------+--------+----------------------------------------------------------------------------------------+
| salesperson_id | order_number | order_date | amount | sum(amount) over(order by order_date rows between unbounded preceding and current row) |
+----------------+--------------+------------+--------+----------------------------------------------------------------------------------------+
|              1 |           30 | 1995-07-14 |    460 |                                                                                    460 |
|              2 |           10 | 1996-08-02 |    540 |                                                                                   1000 |
|              2 |           40 | 1998-01-29 |   2400 |                                                                                   3400 |
|              7 |           50 | 1998-02-03 |    600 |                                                                                   4000 |
|              7 |           60 | 1998-03-02 |    720 |                                                                                   4720 |
|              7 |           70 | 1998-05-06 |    150 |                                                                                   4870 |
|              8 |           20 | 1999-01-30 |   1800 |                                                                                   6670 |
+----------------+--------------+------------+--------+----------------------------------------------------------------------------------------+







select salesperson_id,order_number,order_date,amount,sum(amount) over(partition by salesperson_id order by order_date rows between 1 preceding and current row) as sum from sales;


+----------------+--------------+------------+--------+------+
| salesperson_id | order_number | order_date | amount | sum  |
+----------------+--------------+------------+--------+------+
|              1 |           30 | 1995-07-14 |    460 |  460 |
|              2 |           10 | 1996-08-02 |    540 |  540 |
|              2 |           40 | 1998-01-29 |   2400 | 2940 |
|              7 |           50 | 1998-02-03 |    600 |  600 |
|              7 |           60 | 1998-03-02 |    720 | 1320 |
|              7 |           70 | 1998-05-06 |    150 |  870 |
|              8 |           20 | 1999-01-30 |   1800 | 1800 |
+----------------+--------------+------------+--------+------+







select salesperson_id,order_number,order_date,amount,sum(amount) over(order by order_date rows between 1 preceding and 1 preceding) as sum from sales;


+----------------+--------------+------------+--------+------+
| salesperson_id | order_number | order_date | amount | sum  |
+----------------+--------------+------------+--------+------+
|              1 |           30 | 1995-07-14 |    460 | NULL |
|              2 |           10 | 1996-08-02 |    540 |  460 |
|              2 |           40 | 1998-01-29 |   2400 |  540 |
|              7 |           50 | 1998-02-03 |    600 | 2400 |
|              7 |           60 | 1998-03-02 |    720 |  600 |
|              7 |           70 | 1998-05-06 |    150 |  720 |
|              8 |           20 | 1999-01-30 |   1800 |  150 |
+----------------+--------------+------------+--------+------+








select salesperson_id,order_number,order_date,amount,sum(amount) over(order by order_date rows between 1 following and 1 following) as sum from sales;

+----------------+--------------+------------+--------+------+
| salesperson_id | order_number | order_date | amount | sum  |
+----------------+--------------+------------+--------+------+
|              1 |           30 | 1995-07-14 |    460 |  540 |
|              2 |           10 | 1996-08-02 |    540 | 2400 |
|              2 |           40 | 1998-01-29 |   2400 |  600 |
|              7 |           50 | 1998-02-03 |    600 |  720 |
|              7 |           60 | 1998-03-02 |    720 |  150 |
|              7 |           70 | 1998-05-06 |    150 | 1800 |
|              8 |           20 | 1999-01-30 |   1800 | NULL |
+----------------+--------------+------------+--------+------+



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SELF JOIN 
_________

Q) FIND EMPLOYEES WITH SALARY MORE THAN THEIR MANAGERS SALARY


TABLE NAME : EMP
-------------------------------------------
| emp_id | emp_name | salary | manager_id |
|--------|----------|--------|------------|
| 1      | Ankit    | 10000  | 4          |
| 2      | Mohit    | 15000  | 5          |
| 3      | Vikas    | 10000  | 4          |
| 4      | Rohit    | 5000   | 2          |
| 5      | Mudit    | 12000  | 6          |
| 6      | Agam     | 12000  | 2          |
| 7      | Sanjay   | 9000   | 2          |
| 8      | Ashish   | 5000   | 2          |
-------------------------------------------

TABLE NAME : MGR
-------------------------------------------
| emp_id | emp_name | salary | manager_id |
|--------|----------|--------|------------|
| 1      | Ankit    | 10000  | 4          |
| 2      | Mohit    | 15000  | 5          |
| 3      | Vikas    | 10000  | 4          |
| 4      | Rohit    | 5000   | 2          |
| 5      | Mudit    | 12000  | 6          |
| 6      | Agam     | 12000  | 2          |
| 7      | Sanjay   | 9000   | 2          |
| 8      | Ashish   | 5000   | 2          |
-------------------------------------------
JOINING    MANAGER_ID OF EMP TABLE     WITH     EMP_ID OF MGR TABLE 



CREATE TABLE EMP 
(
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    salary INT,
    manager_id INT
);

INSERT INTO EMP (emp_id, emp_name, salary, manager_id) VALUES
(1, 'Ankit', 10000, 4),
(2, 'Mohit', 15000, 5),
(3, 'Vikas', 10000, 4),
(4, 'Rohit', 5000, 2),
(5, 'Mudit', 12000, 6),
(6, 'Agam', 12000, 2),
(7, 'Sanjay', 9000, 2),
(8, 'Ashish', 5000, 2);


select e.emp_id,e.emp_name,m.emp_name as manager_name,e.salary,m.salary as manager_salary  from EMP e inner join EMP m on e.manager_id = m.emp_id;

+--------+----------+--------------+--------+----------------+
| emp_id | emp_name | manager_name | salary | manager_salary |
+--------+----------+--------------+--------+----------------+
|      1 | Ankit    | Rohit        |  10000 |           5000 |
|      2 | Mohit    | Mudit        |  15000 |          12000 |
|      3 | Vikas    | Rohit        |  10000 |           5000 |
|      4 | Rohit    | Mohit        |   5000 |          15000 |
|      5 | Mudit    | Agam         |  12000 |          12000 |
|      6 | Agam     | Mohit        |  12000 |          15000 |
|      7 | Sanjay   | Mohit        |   9000 |          15000 |
|      8 | Ashish   | Mohit        |   5000 |          15000 |
+--------+----------+--------------+--------+----------------+



ANS)
select e.emp_id,e.emp_name,m.emp_name as manager_name,e.salary,m.salary as manager_salary  from EMP e inner join EMP m on e.manager_id = m.emp_id where e.salary > m.salary;

+--------+----------+--------------+--------+----------------+
| emp_id | emp_name | manager_name | salary | manager_salary |
+--------+----------+--------------+--------+----------------+
|      1 | Ankit    | Rohit        |  10000 |           5000 |
|      2 | Mohit    | Mudit        |  15000 |          12000 |
|      3 | Vikas    | Rohit        |  10000 |           5000 |
+--------+----------+--------------+--------+----------------+


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


QUESTION BASED ON FULL OUTER JOIN : 
-----------------------------------
-> ***MYSQL DOESNOT SUPPORT FULL OUTER JOIN


Q) FIND THE CHANGE IN EMPLOYEES STATUS



create table emp_2020
(
   emp_id int primary key,
   designation varchar(50)
);
insert into emp_2020 values(1,'Trainee'),(2,'Developer'),(3,'Senior Developer'),(4,'Manager');

create table emp_2021
(
   emp_id int primary key,
   designation varchar(50)
);
insert into emp_2021 values(1,'Developer'),(2,'Developer'),(3,'Manager'),(5,'Trainee');

select * from emp_2020;
+--------+------------------+
| emp_id | designation      |
+--------+------------------+
|      1 | Trainee          |
|      2 | Developer        |
|      3 | Senior Developer |
|      4 | Manager          |
+--------+------------------+


select * from emp_2021;
+--------+-------------+
| emp_id | designation |
+--------+-------------+
|      1 | Developer   |
|      2 | Developer   |
|      3 | Manager     |
|      5 | Trainee     |
+--------+-------------+


select e20.*,e21.* from emp_2020 e20 left outer join emp_2021 e21 on e20.emp_id = e21.emp_id
union
select e20.*,e21.* from emp_2020 e20 right outer join emp_2021 e21 on e20.emp_id = e21.emp_id;

+--------+------------------+--------+-------------+
| emp_id | designation      | emp_id | designation |
+--------+------------------+--------+-------------+
|      1 | Trainee          |      1 | Developer   |
|      2 | Developer        |      2 | Developer   |
|      3 | Senior Developer |      3 | Manager     |
|      4 | Manager          |   NULL | NULL        |
|   NULL | NULL             |      5 | Trainee     |
+--------+------------------+--------+-------------+




select e20.*,e21.*,case when e20.designation!=e21.designation then 'Promoted'
when e21.designation is null then 'Resigned'
else 'New' end as comment
from emp_2020 e20 left outer join emp_2021 e21 on e20.emp_id = e21.emp_id where ifnull(e20.designation,'xxx') != ifnull(e21.designation,'yyy')

union

select e20.*,e21.*,case when e20.designation!=e21.designation then 'Promoted'
when e21.designation is null then 'Resigned'
else 'New' end as comment
from emp_2020 e20 right outer join emp_2021 e21 on e20.emp_id = e21.emp_id where ifnull(e20.designation,'xxx') != ifnull(e21.designation,'yyy');
+--------+------------------+--------+-------------+----------+
| emp_id | designation      | emp_id | designation | comment  |
+--------+------------------+--------+-------------+----------+
|      1 | Trainee          |      1 | Developer   | Promoted |
|      3 | Senior Developer |      3 | Manager     | Promoted |
|      4 | Manager          |   NULL | NULL        | Resigned |
|   NULL | NULL             |      5 | Trainee     | New      |
+--------+------------------+--------+-------------+----------+





select ifnull(e20.emp_id,e21.emp_id) as emp_id , case when e20.designation!=e21.designation then 'Promoted'
when e21.designation is null then 'Resigned'
else 'New' end as comment
from emp_2020 e20 left outer join emp_2021 e21 on e20.emp_id = e21.emp_id where ifnull(e20.designation,'xxx') != ifnull(e21.designation,'yyy')
union
select ifnull(e20.emp_id,e21.emp_id) as emp_id , case when e20.designation!=e21.designation then 'Promoted'
when e21.designation is null then 'Resigned'
else 'New' end as comment
from emp_2020 e20 right outer join emp_2021 e21 on e20.emp_id = e21.emp_id where ifnull(e20.designation,'xxx') != ifnull(e21.designation,'yyy');
+--------+----------+
| emp_id | comment  |
+--------+----------+
|      1 | Promoted |
|      3 | Promoted |
|      4 | Resigned |
|      5 | New      |
+--------+----------+

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


LAG()  AND LEAD() FUNCTIONS IN MYSQL
____________________________________

-> THE LAG() FUNCTION IS USED TO GET THE VALUE OF A COLUMN FROM THE PREVIOUS ROW IN THE RESULT SET.

LAG(COLUMN_NAME, OFFSET, DEFAULT_VALUE) OVER (PARTITION BY COLUMN_NAME ORDER BY COLUMN_NAME)
COLUMN_NAME: THE COLUMN WHOSE VALUE YOU WANT FROM THE PREVIOUS ROW.
OFFSET: HOW MANY ROWS BACK TO LOOK. DEFAULTS TO 1.
DEFAULT_VALUE: THE VALUE TO RETURN IF THERE IS NO PREVIOUS ROW. DEFAULTS TO NULL.
OVER (PARTITION BY ...) SPECIFIES HOW THE DATA IS PARTITIONED AND SORTED.



-> THE LEAD() FUNCTION IS USED TO GET THE VALUE OF A COLUMN FROM THE NEXT ROW IN THE RESULT SET.

LEAD(COLUMN_NAME, OFFSET, DEFAULT_VALUE) OVER (PARTITION BY COLUMN_NAME ORDER BY COLUMN_NAME)
COLUMN_NAME: THE COLUMN WHOSE VALUE YOU WANT FROM THE NEXT ROW.
OFFSET: HOW MANY ROWS AHEAD TO LOOK. DEFAULTS TO 1.
DEFAULT_VALUE: THE VALUE TO RETURN IF THERE IS NO NEXT ROW. DEFAULTS TO NULL.
OVER (PARTITION BY ...) SPECIFIES HOW THE DATA IS PARTITIONED AND SORTED.



THE OVER CLAUSE IS REQUIRED WHEN USING THE LAG() FUNCTION IN MYSQL.
ORDER BY INSIDE THE OVER CLAUSE IS ALSO REQUIRED TO DEFINE THE ROW ORDER.
PARTITION BY IS OPTIONAL, AND IF YOU DON'T NEED PARTITIONING, YOU CAN LEAVE IT OUT, BUT YOU MUST STILL USE ORDER BY.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DATE AND TIME FUNCTIONS : 
_________________________




















